"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "app/api/detect-keywords/route";
exports.ids = ["app/api/detect-keywords/route"];
exports.modules = {

/***/ "next/dist/compiled/next-server/app-route.runtime.dev.js":
/*!**************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-route.runtime.dev.js" ***!
  \**************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/app-route.runtime.dev.js");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ ((module) => {

module.exports = require("fs");

/***/ }),

/***/ "http":
/*!***********************!*\
  !*** external "http" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("http");

/***/ }),

/***/ "https":
/*!************************!*\
  !*** external "https" ***!
  \************************/
/***/ ((module) => {

module.exports = require("https");

/***/ }),

/***/ "node:fs":
/*!**************************!*\
  !*** external "node:fs" ***!
  \**************************/
/***/ ((module) => {

module.exports = require("node:fs");

/***/ }),

/***/ "node:stream":
/*!******************************!*\
  !*** external "node:stream" ***!
  \******************************/
/***/ ((module) => {

module.exports = require("node:stream");

/***/ }),

/***/ "node:stream/web":
/*!**********************************!*\
  !*** external "node:stream/web" ***!
  \**********************************/
/***/ ((module) => {

module.exports = require("node:stream/web");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("path");

/***/ }),

/***/ "punycode":
/*!***************************!*\
  !*** external "punycode" ***!
  \***************************/
/***/ ((module) => {

module.exports = require("punycode");

/***/ }),

/***/ "stream":
/*!*************************!*\
  !*** external "stream" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("stream");

/***/ }),

/***/ "url":
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/***/ ((module) => {

module.exports = require("url");

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("util");

/***/ }),

/***/ "worker_threads":
/*!*********************************!*\
  !*** external "worker_threads" ***!
  \*********************************/
/***/ ((module) => {

module.exports = require("worker_threads");

/***/ }),

/***/ "zlib":
/*!***********************!*\
  !*** external "zlib" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("zlib");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fdetect-keywords%2Froute&page=%2Fapi%2Fdetect-keywords%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fdetect-keywords%2Froute.ts&appDir=%2Fhome%2Frishi%2FDesktop%2Fhackathon%2FHelloWorld2025%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2Fhome%2Frishi%2FDesktop%2Fhackathon%2FHelloWorld2025&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!":
/*!*************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fdetect-keywords%2Froute&page=%2Fapi%2Fdetect-keywords%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fdetect-keywords%2Froute.ts&appDir=%2Fhome%2Frishi%2FDesktop%2Fhackathon%2FHelloWorld2025%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2Fhome%2Frishi%2FDesktop%2Fhackathon%2FHelloWorld2025&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D! ***!
  \*************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   headerHooks: () => (/* binding */ headerHooks),\n/* harmony export */   originalPathname: () => (/* binding */ originalPathname),\n/* harmony export */   patchFetch: () => (/* binding */ patchFetch),\n/* harmony export */   requestAsyncStorage: () => (/* binding */ requestAsyncStorage),\n/* harmony export */   routeModule: () => (/* binding */ routeModule),\n/* harmony export */   serverHooks: () => (/* binding */ serverHooks),\n/* harmony export */   staticGenerationAsyncStorage: () => (/* binding */ staticGenerationAsyncStorage),\n/* harmony export */   staticGenerationBailout: () => (/* binding */ staticGenerationBailout)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/future/route-modules/app-route/module.compiled */ \"(rsc)/./node_modules/next/dist/server/future/route-modules/app-route/module.compiled.js\");\n/* harmony import */ var next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/future/route-kind */ \"(rsc)/./node_modules/next/dist/server/future/route-kind.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/server/lib/patch-fetch */ \"(rsc)/./node_modules/next/dist/server/lib/patch-fetch.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _home_rishi_Desktop_hackathon_HelloWorld2025_app_api_detect_keywords_route_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./app/api/detect-keywords/route.ts */ \"(rsc)/./app/api/detect-keywords/route.ts\");\n\n\n\n\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\nconst nextConfigOutput = \"\"\nconst routeModule = new next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__.AppRouteRouteModule({\n    definition: {\n        kind: next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.APP_ROUTE,\n        page: \"/api/detect-keywords/route\",\n        pathname: \"/api/detect-keywords\",\n        filename: \"route\",\n        bundlePath: \"app/api/detect-keywords/route\"\n    },\n    resolvedPagePath: \"/home/rishi/Desktop/hackathon/HelloWorld2025/app/api/detect-keywords/route.ts\",\n    nextConfigOutput,\n    userland: _home_rishi_Desktop_hackathon_HelloWorld2025_app_api_detect_keywords_route_ts__WEBPACK_IMPORTED_MODULE_3__\n});\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { requestAsyncStorage, staticGenerationAsyncStorage, serverHooks, headerHooks, staticGenerationBailout } = routeModule;\nconst originalPathname = \"/api/detect-keywords/route\";\nfunction patchFetch() {\n    return (0,next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__.patchFetch)({\n        serverHooks,\n        staticGenerationAsyncStorage\n    });\n}\n\n\n//# sourceMappingURL=app-route.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWFwcC1sb2FkZXIuanM/bmFtZT1hcHAlMkZhcGklMkZkZXRlY3Qta2V5d29yZHMlMkZyb3V0ZSZwYWdlPSUyRmFwaSUyRmRldGVjdC1rZXl3b3JkcyUyRnJvdXRlJmFwcFBhdGhzPSZwYWdlUGF0aD1wcml2YXRlLW5leHQtYXBwLWRpciUyRmFwaSUyRmRldGVjdC1rZXl3b3JkcyUyRnJvdXRlLnRzJmFwcERpcj0lMkZob21lJTJGcmlzaGklMkZEZXNrdG9wJTJGaGFja2F0aG9uJTJGSGVsbG9Xb3JsZDIwMjUlMkZhcHAmcGFnZUV4dGVuc2lvbnM9dHN4JnBhZ2VFeHRlbnNpb25zPXRzJnBhZ2VFeHRlbnNpb25zPWpzeCZwYWdlRXh0ZW5zaW9ucz1qcyZyb290RGlyPSUyRmhvbWUlMkZyaXNoaSUyRkRlc2t0b3AlMkZoYWNrYXRob24lMkZIZWxsb1dvcmxkMjAyNSZpc0Rldj10cnVlJnRzY29uZmlnUGF0aD10c2NvbmZpZy5qc29uJmJhc2VQYXRoPSZhc3NldFByZWZpeD0mbmV4dENvbmZpZ091dHB1dD0mcHJlZmVycmVkUmVnaW9uPSZtaWRkbGV3YXJlQ29uZmlnPWUzMCUzRCEiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBc0c7QUFDdkM7QUFDYztBQUM2QjtBQUMxRztBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0hBQW1CO0FBQzNDO0FBQ0EsY0FBYyx5RUFBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsWUFBWTtBQUNaLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxRQUFRLHVHQUF1RztBQUMvRztBQUNBO0FBQ0EsV0FBVyw0RUFBVztBQUN0QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQzZKOztBQUU3SiIsInNvdXJjZXMiOlsid2VicGFjazovL3BkZi1rZXl3b3JkLWFuYWx5emVyLz83ODIwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFwcFJvdXRlUm91dGVNb2R1bGUgfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9mdXR1cmUvcm91dGUtbW9kdWxlcy9hcHAtcm91dGUvbW9kdWxlLmNvbXBpbGVkXCI7XG5pbXBvcnQgeyBSb3V0ZUtpbmQgfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9mdXR1cmUvcm91dGUta2luZFwiO1xuaW1wb3J0IHsgcGF0Y2hGZXRjaCBhcyBfcGF0Y2hGZXRjaCB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL2xpYi9wYXRjaC1mZXRjaFwiO1xuaW1wb3J0ICogYXMgdXNlcmxhbmQgZnJvbSBcIi9ob21lL3Jpc2hpL0Rlc2t0b3AvaGFja2F0aG9uL0hlbGxvV29ybGQyMDI1L2FwcC9hcGkvZGV0ZWN0LWtleXdvcmRzL3JvdXRlLnRzXCI7XG4vLyBXZSBpbmplY3QgdGhlIG5leHRDb25maWdPdXRwdXQgaGVyZSBzbyB0aGF0IHdlIGNhbiB1c2UgdGhlbSBpbiB0aGUgcm91dGVcbi8vIG1vZHVsZS5cbmNvbnN0IG5leHRDb25maWdPdXRwdXQgPSBcIlwiXG5jb25zdCByb3V0ZU1vZHVsZSA9IG5ldyBBcHBSb3V0ZVJvdXRlTW9kdWxlKHtcbiAgICBkZWZpbml0aW9uOiB7XG4gICAgICAgIGtpbmQ6IFJvdXRlS2luZC5BUFBfUk9VVEUsXG4gICAgICAgIHBhZ2U6IFwiL2FwaS9kZXRlY3Qta2V5d29yZHMvcm91dGVcIixcbiAgICAgICAgcGF0aG5hbWU6IFwiL2FwaS9kZXRlY3Qta2V5d29yZHNcIixcbiAgICAgICAgZmlsZW5hbWU6IFwicm91dGVcIixcbiAgICAgICAgYnVuZGxlUGF0aDogXCJhcHAvYXBpL2RldGVjdC1rZXl3b3Jkcy9yb3V0ZVwiXG4gICAgfSxcbiAgICByZXNvbHZlZFBhZ2VQYXRoOiBcIi9ob21lL3Jpc2hpL0Rlc2t0b3AvaGFja2F0aG9uL0hlbGxvV29ybGQyMDI1L2FwcC9hcGkvZGV0ZWN0LWtleXdvcmRzL3JvdXRlLnRzXCIsXG4gICAgbmV4dENvbmZpZ091dHB1dCxcbiAgICB1c2VybGFuZFxufSk7XG4vLyBQdWxsIG91dCB0aGUgZXhwb3J0cyB0aGF0IHdlIG5lZWQgdG8gZXhwb3NlIGZyb20gdGhlIG1vZHVsZS4gVGhpcyBzaG91bGRcbi8vIGJlIGVsaW1pbmF0ZWQgd2hlbiB3ZSd2ZSBtb3ZlZCB0aGUgb3RoZXIgcm91dGVzIHRvIHRoZSBuZXcgZm9ybWF0LiBUaGVzZVxuLy8gYXJlIHVzZWQgdG8gaG9vayBpbnRvIHRoZSByb3V0ZS5cbmNvbnN0IHsgcmVxdWVzdEFzeW5jU3RvcmFnZSwgc3RhdGljR2VuZXJhdGlvbkFzeW5jU3RvcmFnZSwgc2VydmVySG9va3MsIGhlYWRlckhvb2tzLCBzdGF0aWNHZW5lcmF0aW9uQmFpbG91dCB9ID0gcm91dGVNb2R1bGU7XG5jb25zdCBvcmlnaW5hbFBhdGhuYW1lID0gXCIvYXBpL2RldGVjdC1rZXl3b3Jkcy9yb3V0ZVwiO1xuZnVuY3Rpb24gcGF0Y2hGZXRjaCgpIHtcbiAgICByZXR1cm4gX3BhdGNoRmV0Y2goe1xuICAgICAgICBzZXJ2ZXJIb29rcyxcbiAgICAgICAgc3RhdGljR2VuZXJhdGlvbkFzeW5jU3RvcmFnZVxuICAgIH0pO1xufVxuZXhwb3J0IHsgcm91dGVNb2R1bGUsIHJlcXVlc3RBc3luY1N0b3JhZ2UsIHN0YXRpY0dlbmVyYXRpb25Bc3luY1N0b3JhZ2UsIHNlcnZlckhvb2tzLCBoZWFkZXJIb29rcywgc3RhdGljR2VuZXJhdGlvbkJhaWxvdXQsIG9yaWdpbmFsUGF0aG5hbWUsIHBhdGNoRmV0Y2gsICB9O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcHAtcm91dGUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fdetect-keywords%2Froute&page=%2Fapi%2Fdetect-keywords%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fdetect-keywords%2Froute.ts&appDir=%2Fhome%2Frishi%2FDesktop%2Fhackathon%2FHelloWorld2025%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2Fhome%2Frishi%2FDesktop%2Fhackathon%2FHelloWorld2025&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!\n");

/***/ }),

/***/ "(rsc)/./app/api/detect-keywords/route.ts":
/*!******************************************!*\
  !*** ./app/api/detect-keywords/route.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   POST: () => (/* binding */ POST)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_web_exports_next_response__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/web/exports/next-response */ \"(rsc)/./node_modules/next/dist/server/web/exports/next-response.js\");\n/* harmony import */ var openai__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! openai */ \"(rsc)/./node_modules/openai/index.mjs\");\n/**\n * API Route: Detect Keywords\n * \n * This API endpoint uses advanced semantic analysis to detect and extract keywords\n * from PDF text content. It employs multiple strategies including technical term\n * detection, frequency analysis, and contextual importance scoring.\n * \n * Features:\n * - Semantic fingerprint analysis for document structure understanding\n * - Multi-strategy keyword extraction (technical terms, phrases, domain-specific)\n * - AI-powered definition generation using OpenAI GPT-4\n * - Fallback to semantic analysis when AI is unavailable\n * - Context-aware keyword scoring and ranking\n * \n * @fileoverview API route for intelligent keyword detection from PDF text\n * @author PDF Keyword Analyzer Team\n * @version 1.0.0\n */ \n\n// Initialize OpenAI client for AI-powered definitions\nconst openai = new openai__WEBPACK_IMPORTED_MODULE_1__[\"default\"]({\n    apiKey: process.env.OPENAI_API_KEY\n});\n/**\n * POST /api/detect-keywords\n * \n * Detects and extracts keywords from PDF text using semantic analysis.\n * \n * Request Body:\n * - text: string - The extracted text content from PDF\n * \n * Response:\n * - keywords: Array of keyword objects with word, definition, context, and isGPT flag\n * \n * @param request - Next.js request object containing PDF text\n * @returns JSON response with detected keywords and their definitions\n */ async function POST(request) {\n    try {\n        const { text } = await request.json();\n        // Validate required input\n        if (!text) {\n            return next_dist_server_web_exports_next_response__WEBPACK_IMPORTED_MODULE_0__[\"default\"].json({\n                error: \"Text is required\"\n            }, {\n                status: 400\n            });\n        }\n        // Use advanced semantic fingerprint-based keyword detection\n        const keywords = await semanticFingerprintKeywordDetection(text);\n        return next_dist_server_web_exports_next_response__WEBPACK_IMPORTED_MODULE_0__[\"default\"].json({\n            keywords\n        });\n    } catch (error) {\n        console.error(\"Error detecting keywords:\", error);\n        return next_dist_server_web_exports_next_response__WEBPACK_IMPORTED_MODULE_0__[\"default\"].json({\n            error: \"Failed to detect keywords\"\n        }, {\n            status: 500\n        });\n    }\n}\n/**\n * Semantic Fingerprint Keyword Detection\n * \n * This is the core function that performs advanced keyword detection using\n * multiple semantic analysis strategies. It creates a \"fingerprint\" of the\n * document to understand its structure and content, then applies various\n * extraction strategies to identify the most important terms.\n * \n * Process:\n * 1. Clean and preprocess the text\n * 2. Analyze document structure and semantic patterns\n * 3. Apply multiple extraction strategies in parallel\n * 4. Score and rank keywords by importance\n * 5. Generate AI-powered definitions for top keywords\n * \n * @param text - Raw text content from PDF\n * @returns Promise resolving to array of keyword objects with definitions\n */ async function semanticFingerprintKeywordDetection(text) {\n    const keywords = [];\n    const foundTerms = new Set();\n    // Clean the text to remove non-content sections (references, headers, etc.)\n    const cleanText = cleanTextForKeywordDetection(text);\n    // Create semantic fingerprint to understand document structure and patterns\n    const semanticFingerprint = analyzeSemanticFingerprint(cleanText);\n    // Apply multiple extraction strategies in parallel for comprehensive coverage\n    const strategies = [\n        ()=>extractTechnicalTerms(cleanText, semanticFingerprint),\n        ()=>extractFrequentIntegralTerms(cleanText, semanticFingerprint),\n        ()=>extractContextualKeywords(cleanText, semanticFingerprint),\n        ()=>extractDomainSpecificTerms(cleanText, semanticFingerprint),\n        ()=>extractSemanticClusters(cleanText, semanticFingerprint),\n        ()=>extractMultiWordPhrases(cleanText, semanticFingerprint)\n    ];\n    // Execute all strategies and collect unique keywords\n    strategies.forEach((strategy)=>{\n        const extractedKeywords = strategy();\n        extractedKeywords.forEach((keyword)=>{\n            if (!foundTerms.has(keyword.word.toLowerCase())) {\n                foundTerms.add(keyword.word.toLowerCase());\n                keywords.push(keyword);\n            }\n        });\n    });\n    // Remove duplicates and sort by semantic importance score\n    const uniqueKeywords = keywords.filter((keyword, index, self)=>index === self.findIndex((k)=>k.word.toLowerCase() === keyword.word.toLowerCase()));\n    // Sort by semantic importance score (higher is better)\n    uniqueKeywords.sort((a, b)=>b.score - a.score);\n    // Generate AI-powered definitions for top 20 keywords\n    const keywordsWithDefinitions = await Promise.all(uniqueKeywords.slice(0, 20).map(async (k)=>{\n        const definitionResult = await generateDefinition(k.word, cleanText, semanticFingerprint);\n        return {\n            word: k.word,\n            definition: definitionResult.definition,\n            context: k.context,\n            isGPT: definitionResult.isGPT\n        };\n    }));\n    return keywordsWithDefinitions;\n}\nfunction analyzeSemanticFingerprint(text) {\n    const fingerprint = {\n        // Document structure analysis\n        sections: extractDocumentSections(text),\n        // Word frequency analysis\n        wordFrequencies: calculateWordFrequencies(text),\n        // Technical term density\n        technicalDensity: calculateTechnicalDensity(text),\n        // Semantic clusters\n        semanticClusters: identifySemanticClusters(text),\n        // Contextual importance\n        contextualImportance: calculateContextualImportance(text),\n        // Domain indicators\n        domainIndicators: identifyDomainIndicators(text)\n    };\n    return fingerprint;\n}\nfunction extractDocumentSections(text) {\n    const sections = {\n        abstract: extractSection(text, /abstract\\s*:?/i),\n        introduction: extractSection(text, /introduction\\s*:?/i),\n        methodology: extractSection(text, /method(?:ology|s)?\\s*:?/i),\n        results: extractSection(text, /results?\\s*:?/i),\n        discussion: extractSection(text, /discussion\\s*:?/i),\n        conclusion: extractSection(text, /conclusion\\s*:?/i)\n    };\n    return sections;\n}\nfunction extractSection(text, pattern) {\n    const match = text.match(new RegExp(pattern.source + \"([\\\\s\\\\S]*?)(?=\\\\n\\\\n[A-Z]|\\\\n[A-Z][a-z]+\\\\s*:?|$)\", \"i\"));\n    return match ? match[1].trim() : \"\";\n}\nfunction calculateWordFrequencies(text) {\n    const words = text.toLowerCase().match(/\\b[a-zA-Z]{3,}\\b/g) || [];\n    const frequencies = {};\n    words.forEach((word)=>{\n        frequencies[word] = (frequencies[word] || 0) + 1;\n    });\n    return frequencies;\n}\nfunction calculateTechnicalDensity(text) {\n    const technicalPatterns = [\n        /\\b\\w*(?:ology|ism|tion|sion|ment|ness|ity|ive|ical|able|ible|graphy|metry|nomy|pathy|phobia|philia|ization|ification)\\b/gi,\n        /\\b[A-Z]{2,6}\\b/g,\n        /\\b\\w*\\d+\\w*\\b/g\n    ];\n    let technicalCount = 0;\n    technicalPatterns.forEach((pattern)=>{\n        const matches = text.match(pattern);\n        if (matches) technicalCount += matches.length;\n    });\n    const totalWords = (text.match(/\\b\\w+\\b/g) || []).length;\n    return totalWords > 0 ? technicalCount / totalWords : 0;\n}\nfunction identifySemanticClusters(text) {\n    // Group related terms based on co-occurrence and semantic patterns\n    const clusters = [];\n    // Common semantic clusters in academic papers\n    const clusterPatterns = [\n        // Research methodology cluster\n        [\n            \"research\",\n            \"study\",\n            \"experiment\",\n            \"method\",\n            \"analysis\",\n            \"data\",\n            \"results\",\n            \"findings\"\n        ],\n        // Technical implementation cluster\n        [\n            \"algorithm\",\n            \"model\",\n            \"system\",\n            \"framework\",\n            \"approach\",\n            \"technique\",\n            \"methodology\"\n        ],\n        // Statistical analysis cluster\n        [\n            \"statistical\",\n            \"correlation\",\n            \"regression\",\n            \"significance\",\n            \"hypothesis\",\n            \"p-value\",\n            \"confidence\"\n        ],\n        // Machine learning cluster\n        [\n            \"machine\",\n            \"learning\",\n            \"neural\",\n            \"network\",\n            \"artificial\",\n            \"intelligence\",\n            \"algorithm\",\n            \"model\"\n        ],\n        // Performance evaluation cluster\n        [\n            \"performance\",\n            \"accuracy\",\n            \"efficiency\",\n            \"evaluation\",\n            \"assessment\",\n            \"measurement\",\n            \"benchmark\"\n        ]\n    ];\n    clusterPatterns.forEach((cluster)=>{\n        const foundTerms = cluster.filter((term)=>new RegExp(`\\\\b${term}\\\\b`, \"i\").test(text));\n        if (foundTerms.length >= 2) {\n            clusters.push(foundTerms);\n        }\n    });\n    return clusters;\n}\nfunction calculateContextualImportance(text) {\n    const importance = {};\n    // Terms that appear in multiple sections are more important\n    const sections = extractDocumentSections(text);\n    const allSectionText = Object.values(sections).join(\" \");\n    // Calculate importance based on section presence and frequency\n    const words = allSectionText.toLowerCase().match(/\\b[a-zA-Z]{4,}\\b/g) || [];\n    const wordCounts = {};\n    words.forEach((word)=>{\n        wordCounts[word] = (wordCounts[word] || 0) + 1;\n    });\n    Object.entries(wordCounts).forEach(([word, count])=>{\n        // Importance score based on frequency and section diversity\n        let score = count;\n        Object.values(sections).forEach((section)=>{\n            if (section.toLowerCase().includes(word)) {\n                score += 1;\n            }\n        });\n        importance[word] = score;\n    });\n    return importance;\n}\nfunction identifyDomainIndicators(text) {\n    const domainPatterns = [\n        // Computer Science\n        /\\b(?:algorithm|programming|software|hardware|database|network|security|artificial|intelligence|machine|learning)\\b/gi,\n        // Medicine/Biology\n        /\\b(?:patient|clinical|medical|biological|genetic|protein|cell|disease|treatment|therapy)\\b/gi,\n        // Psychology\n        /\\b(?:psychological|behavior|cognitive|mental|therapy|counseling|assessment|personality)\\b/gi,\n        // Economics\n        /\\b(?:economic|financial|market|investment|revenue|profit|cost|price|demand|supply)\\b/gi,\n        // Physics\n        /\\b(?:quantum|particle|energy|force|motion|wave|field|electromagnetic|nuclear|atomic)\\b/gi\n    ];\n    const domains = [];\n    domainPatterns.forEach((pattern, index)=>{\n        const matches = text.match(pattern);\n        if (matches && matches.length > 3) {\n            const domainNames = [\n                \"Computer Science\",\n                \"Medicine/Biology\",\n                \"Psychology\",\n                \"Economics\",\n                \"Physics\"\n            ];\n            domains.push(domainNames[index]);\n        }\n    });\n    return domains;\n}\nfunction extractTechnicalTerms(text, fingerprint) {\n    const keywords = [];\n    const technicalPatterns = [\n        // Acronyms\n        {\n            pattern: /\\b[A-Z]{2,6}\\b/g,\n            weight: 0.9\n        },\n        // Technical suffixes\n        {\n            pattern: /\\b\\w*(?:ology|ism|tion|sion|ment|ness|ity|ive|ical|able|ible|graphy|metry|nomy|pathy|phobia|philia|ization|ification)\\b/gi,\n            weight: 0.8\n        },\n        // Scientific notation\n        {\n            pattern: /\\b\\w*\\d+\\w*\\b/g,\n            weight: 0.7\n        },\n        // Compound terms\n        {\n            pattern: /\\b\\w+(?:-|_)\\w+\\b/g,\n            weight: 0.6\n        }\n    ];\n    technicalPatterns.forEach(({ pattern, weight })=>{\n        const matches = text.match(pattern);\n        if (matches) {\n            matches.forEach((match)=>{\n                if (match.length > 2 && !isCommonWord(match)) {\n                    keywords.push({\n                        word: match,\n                        context: extractContext(text, match),\n                        score: weight * (fingerprint.wordFrequencies[match.toLowerCase()] || 1)\n                    });\n                }\n            });\n        }\n    });\n    return keywords;\n}\nfunction extractFrequentIntegralTerms(text, fingerprint) {\n    const keywords = [];\n    Object.entries(fingerprint.wordFrequencies).forEach(([word, count])=>{\n        const frequency = count;\n        if (frequency >= 3 && word.length > 3 && !isCommonWord(word)) {\n            const contextualScore = fingerprint.contextualImportance[word] || frequency;\n            keywords.push({\n                word: word.charAt(0).toUpperCase() + word.slice(1),\n                context: extractContext(text, word),\n                score: contextualScore * 0.5\n            });\n        }\n    });\n    return keywords;\n}\nfunction extractContextualKeywords(text, fingerprint) {\n    const keywords = [];\n    // Extract terms that appear in multiple sections\n    const sectionTerms = {};\n    Object.entries(fingerprint.sections).forEach(([sectionName, sectionText])=>{\n        if (sectionText && typeof sectionText === \"string\") {\n            const words = sectionText.toLowerCase().match(/\\b[a-zA-Z]{4,}\\b/g) || [];\n            words.forEach((word)=>{\n                if (!isCommonWord(word)) {\n                    sectionTerms[word] = (sectionTerms[word] || 0) + 1;\n                }\n            });\n        }\n    });\n    Object.entries(sectionTerms).forEach(([word, sectionCount])=>{\n        if (sectionCount >= 2) {\n            keywords.push({\n                word: word.charAt(0).toUpperCase() + word.slice(1),\n                context: extractContext(text, word),\n                score: sectionCount * 0.7\n            });\n        }\n    });\n    return keywords;\n}\nfunction extractDomainSpecificTerms(text, fingerprint) {\n    const keywords = [];\n    // Domain-specific term patterns\n    const domainTerms = [\n        // Research terms\n        \"hypothesis\",\n        \"methodology\",\n        \"empirical\",\n        \"quantitative\",\n        \"qualitative\",\n        \"longitudinal\",\n        \"cross-sectional\",\n        // Statistical terms\n        \"correlation\",\n        \"regression\",\n        \"significance\",\n        \"p-value\",\n        \"confidence\",\n        \"interval\",\n        \"effect\",\n        \"size\",\n        // Technical terms\n        \"algorithm\",\n        \"optimization\",\n        \"implementation\",\n        \"evaluation\",\n        \"benchmark\",\n        \"performance\",\n        \"accuracy\",\n        // Scientific terms\n        \"experiment\",\n        \"observation\",\n        \"measurement\",\n        \"analysis\",\n        \"synthesis\",\n        \"validation\",\n        \"verification\"\n    ];\n    domainTerms.forEach((term)=>{\n        const regex = new RegExp(`\\\\b${term}\\\\b`, \"gi\");\n        const matches = text.match(regex);\n        if (matches && matches.length > 0) {\n            keywords.push({\n                word: term.charAt(0).toUpperCase() + term.slice(1),\n                context: extractContext(text, term),\n                score: matches.length * 0.6\n            });\n        }\n    });\n    return keywords;\n}\nfunction extractSemanticClusters(text, fingerprint) {\n    const keywords = [];\n    fingerprint.semanticClusters.forEach((cluster)=>{\n        cluster.forEach((term)=>{\n            const regex = new RegExp(`\\\\b${term}\\\\b`, \"gi\");\n            const matches = text.match(regex);\n            if (matches && matches.length > 0) {\n                keywords.push({\n                    word: term.charAt(0).toUpperCase() + term.slice(1),\n                    context: extractContext(text, term),\n                    score: matches.length * 0.4\n                });\n            }\n        });\n    });\n    return keywords;\n}\nfunction extractMultiWordPhrases(text, fingerprint) {\n    const keywords = [];\n    // Common multi-word technical phrases\n    const phrasePatterns = [\n        // Scientific phrases\n        {\n            pattern: /\\b(?:deep sea|cell death|protein synthesis|DNA replication|gene expression|cell division|immune response|neural network|machine learning|artificial intelligence|data analysis|statistical significance|control group|experimental design)\\b/gi,\n            weight: 0.9\n        },\n        // Medical/Biological phrases\n        {\n            pattern: /\\b(?:blood pressure|heart rate|brain function|muscle contraction|enzyme activity|hormone levels|immune system|nervous system|cardiovascular system|respiratory system)\\b/gi,\n            weight: 0.9\n        },\n        // Technical phrases\n        {\n            pattern: /\\b(?:user interface|database management|network security|software development|hardware configuration|data processing|algorithm design|system architecture|cloud computing|mobile application)\\b/gi,\n            weight: 0.8\n        },\n        // Academic phrases\n        {\n            pattern: /\\b(?:research methodology|literature review|data collection|statistical analysis|hypothesis testing|peer review|academic writing|theoretical framework|empirical evidence|qualitative research|quantitative research)\\b/gi,\n            weight: 0.8\n        },\n        // General compound terms\n        {\n            pattern: /\\b(?:high school|middle school|elementary school|university level|graduate level|undergraduate level|post graduate|doctoral degree|master's degree|bachelor's degree)\\b/gi,\n            weight: 0.7\n        },\n        // Time-related phrases\n        {\n            pattern: /\\b(?:long term|short term|medium term|real time|over time|in time|on time|at the time|for the time|during the time)\\b/gi,\n            weight: 0.6\n        },\n        // Location phrases\n        {\n            pattern: /\\b(?:north america|south america|european union|middle east|far east|central asia|southeast asia|sub saharan|latin america|north africa)\\b/gi,\n            weight: 0.6\n        }\n    ];\n    phrasePatterns.forEach(({ pattern, weight })=>{\n        const matches = text.match(pattern);\n        if (matches) {\n            matches.forEach((match)=>{\n                const phrase = match.trim();\n                if (phrase.length > 3 && !isCommonPhrase(phrase)) {\n                    keywords.push({\n                        word: phrase,\n                        context: extractContext(text, phrase),\n                        score: weight * (fingerprint.wordFrequencies[phrase.toLowerCase()] || 1)\n                    });\n                }\n            });\n        }\n    });\n    // Extract custom phrases from the document (2-4 word combinations that appear frequently)\n    const words = text.toLowerCase().match(/\\b[a-zA-Z]{3,}\\b/g) || [];\n    const phraseCounts = {};\n    // Look for 2-word phrases\n    for(let i = 0; i < words.length - 1; i++){\n        const phrase = `${words[i]} ${words[i + 1]}`;\n        if (!isCommonPhrase(phrase)) {\n            phraseCounts[phrase] = (phraseCounts[phrase] || 0) + 1;\n        }\n    }\n    // Look for 3-word phrases\n    for(let i = 0; i < words.length - 2; i++){\n        const phrase = `${words[i]} ${words[i + 1]} ${words[i + 2]}`;\n        if (!isCommonPhrase(phrase)) {\n            phraseCounts[phrase] = (phraseCounts[phrase] || 0) + 1;\n        }\n    }\n    // Add frequent custom phrases\n    Object.entries(phraseCounts).forEach(([phrase, count])=>{\n        if (count >= 2 && phrase.length > 5) {\n            keywords.push({\n                word: phrase.split(\" \").map((word)=>word.charAt(0).toUpperCase() + word.slice(1)).join(\" \"),\n                context: extractContext(text, phrase),\n                score: count * 0.5\n            });\n        }\n    });\n    return keywords;\n}\nfunction isCommonPhrase(phrase) {\n    const commonPhrases = [\n        \"the same\",\n        \"in the\",\n        \"on the\",\n        \"at the\",\n        \"for the\",\n        \"with the\",\n        \"to the\",\n        \"of the\",\n        \"and the\",\n        \"or the\",\n        \"this is\",\n        \"that is\",\n        \"there is\",\n        \"there are\",\n        \"it is\",\n        \"it was\",\n        \"it has\",\n        \"it will\",\n        \"it can\",\n        \"it may\",\n        \"as well\",\n        \"as well as\",\n        \"such as\",\n        \"for example\",\n        \"for instance\",\n        \"in addition\",\n        \"in fact\",\n        \"in order\",\n        \"at least\",\n        \"at most\",\n        \"at all\",\n        \"at once\",\n        \"at first\",\n        \"at last\",\n        \"at best\",\n        \"at worst\",\n        \"on the other hand\",\n        \"on the contrary\",\n        \"on average\",\n        \"on purpose\",\n        \"on time\",\n        \"on schedule\",\n        \"in general\",\n        \"in particular\",\n        \"in detail\",\n        \"in summary\",\n        \"in conclusion\",\n        \"in other words\",\n        \"for the most part\",\n        \"for the time being\",\n        \"for the sake of\",\n        \"for the purpose of\",\n        \"as a result\",\n        \"as a matter of fact\",\n        \"as a whole\",\n        \"as a rule\",\n        \"as a consequence\",\n        \"due to\",\n        \"because of\",\n        \"in spite of\",\n        \"instead of\",\n        \"rather than\",\n        \"more than\",\n        \"less than\",\n        \"up to\",\n        \"down to\",\n        \"over to\",\n        \"under to\",\n        \"through to\",\n        \"across to\",\n        \"around to\",\n        \"deep sea\",\n        \"cell death\",\n        \"protein synthesis\",\n        \"DNA replication\",\n        \"gene expression\"\n    ];\n    return commonPhrases.includes(phrase.toLowerCase());\n}\nasync function generateDefinition(word, text, fingerprint) {\n    // Check if OpenAI API key is configured\n    if (!process.env.OPENAI_API_KEY || process.env.OPENAI_API_KEY === \"your-openai-api-key\") {\n        console.log(\"OpenAI API key not configured, using fallback semantic analysis for:\", word);\n        return Promise.resolve({\n            definition: generateSemanticDefinition(word, text, fingerprint),\n            isGPT: false\n        });\n    }\n    try {\n        // Use GPT to generate intelligent keyword definition\n        const context = extractContext(text, word, 200);\n        const domains = fingerprint.domainIndicators.join(\", \") || \"general\";\n        const prompt = `\nAnalyze the following keyword and provide a clear, concise definition based on its usage in the document context. Focus on:\n\n1. What the term means in this specific context\n2. Its role or function in the document\n3. Any technical or domain-specific meaning\n4. Keep the definition informative but accessible\n\nKeyword: \"${word}\"\nDocument Context: \"${context}\"\nDomain: ${domains}\n\nProvide a clear, helpful definition in 1-2 sentences:`;\n        const response = await openai.chat.completions.create({\n            model: \"gpt-4\",\n            messages: [\n                {\n                    role: \"system\",\n                    content: \"You are a helpful assistant that provides clear, concise definitions of technical terms based on their usage in documents. Focus on making complex concepts accessible and understandable.\"\n                },\n                {\n                    role: \"user\",\n                    content: prompt\n                }\n            ],\n            max_tokens: 150,\n            temperature: 0.7\n        });\n        const definition = response.choices[0]?.message?.content?.trim();\n        return Promise.resolve({\n            definition: definition || generateSemanticDefinition(word, text, fingerprint),\n            isGPT: !!definition\n        });\n    } catch (error) {\n        console.error(\"GPT keyword definition generation failed for:\", word, error);\n        return Promise.resolve({\n            definition: generateSemanticDefinition(word, text, fingerprint),\n            isGPT: false\n        });\n    }\n}\nfunction generateSemanticDefinition(word, text, fingerprint) {\n    // Generate contextual definition based on usage patterns\n    const context = extractContext(text, word, 200);\n    // Look for definition patterns\n    const definitionPatterns = [\n        new RegExp(`${word}\\\\s*(?:is|are|refers to|means|denotes|represents)\\\\s*([^.]{10,100})`, \"i\"),\n        new RegExp(`(?:is|are|refers to|means|denotes|represents)\\\\s*${word}\\\\s*([^.]{10,100})`, \"i\"),\n        new RegExp(`${word}\\\\s*\\\\(([^)]{10,100})\\\\)`, \"i\")\n    ];\n    for (const pattern of definitionPatterns){\n        const match = context.match(pattern);\n        if (match) {\n            return match[1].trim();\n        }\n    }\n    // Fallback: generate definition based on domain and context\n    const domains = fingerprint.domainIndicators;\n    if (domains.length > 0) {\n        return `A ${domains[0].toLowerCase()} term referring to ${word.toLowerCase()}`;\n    }\n    return `A technical term used in this context`;\n}\nfunction isCommonWord(word) {\n    const commonWords = new Set([\n        \"the\",\n        \"and\",\n        \"for\",\n        \"are\",\n        \"but\",\n        \"not\",\n        \"you\",\n        \"all\",\n        \"can\",\n        \"had\",\n        \"her\",\n        \"was\",\n        \"one\",\n        \"our\",\n        \"out\",\n        \"day\",\n        \"get\",\n        \"has\",\n        \"him\",\n        \"his\",\n        \"how\",\n        \"its\",\n        \"may\",\n        \"new\",\n        \"now\",\n        \"old\",\n        \"see\",\n        \"two\",\n        \"who\",\n        \"boy\",\n        \"did\",\n        \"man\",\n        \"men\",\n        \"put\",\n        \"say\",\n        \"she\",\n        \"too\",\n        \"use\",\n        \"way\",\n        \"will\",\n        \"with\",\n        \"this\",\n        \"that\",\n        \"they\",\n        \"have\",\n        \"been\",\n        \"were\",\n        \"said\",\n        \"each\",\n        \"which\",\n        \"their\",\n        \"time\",\n        \"about\",\n        \"there\",\n        \"could\",\n        \"other\",\n        \"after\",\n        \"first\",\n        \"well\",\n        \"also\",\n        \"where\",\n        \"much\",\n        \"some\",\n        \"these\",\n        \"than\",\n        \"would\",\n        \"like\",\n        \"into\",\n        \"more\",\n        \"come\",\n        \"made\",\n        \"many\",\n        \"most\",\n        \"over\",\n        \"such\",\n        \"take\",\n        \"than\",\n        \"them\",\n        \"very\",\n        \"when\",\n        \"work\",\n        \"year\",\n        \"your\",\n        \"good\",\n        \"know\",\n        \"just\",\n        \"long\",\n        \"make\",\n        \"right\",\n        \"same\",\n        \"seem\",\n        \"tell\",\n        \"turn\",\n        \"want\",\n        \"went\",\n        \"were\",\n        \"what\",\n        \"when\",\n        \"will\",\n        \"with\",\n        \"work\",\n        \"year\",\n        \"your\",\n        \"here\",\n        \"there\",\n        \"where\",\n        \"why\",\n        \"how\",\n        \"what\",\n        \"when\",\n        \"where\",\n        \"why\",\n        \"how\",\n        \"what\",\n        \"when\",\n        \"where\",\n        \"why\",\n        \"how\",\n        \"what\",\n        \"when\"\n    ]);\n    return commonWords.has(word.toLowerCase());\n}\nfunction extractContext(text, term, contextLength = 100) {\n    const index = text.toLowerCase().indexOf(term.toLowerCase());\n    if (index === -1) return \"\";\n    const start = Math.max(0, index - contextLength);\n    const end = Math.min(text.length, index + term.length + contextLength);\n    return text.substring(start, end).trim();\n}\nfunction cleanTextForKeywordDetection(text) {\n    let cleanedText = text;\n    // Remove references/bibliography sections\n    cleanedText = cleanedText.replace(/(references?|bibliography|works cited|sources?)\\s*:?.*$/gim, \"\");\n    // Remove Creative Commons and copyright information\n    cleanedText = cleanedText.replace(/creative commons.*?$/gim, \"\");\n    cleanedText = cleanedText.replace(/copyright.*?$/gim, \"\");\n    cleanedText = cleanedText.replace(/©.*?$/gim, \"\");\n    cleanedText = cleanedText.replace(/all rights reserved.*?$/gim, \"\");\n    // Remove author affiliations and acknowledgments\n    cleanedText = cleanedText.replace(/acknowledgments?.*?$/gim, \"\");\n    cleanedText = cleanedText.replace(/funding.*?$/gim, \"\");\n    cleanedText = cleanedText.replace(/author affiliations?.*?$/gim, \"\");\n    // Remove abstract and metadata sections\n    cleanedText = cleanedText.replace(/abstract\\s*:?.*?(?=\\n\\n|\\n[A-Z]|$)/gim, \"\");\n    cleanedText = cleanedText.replace(/keywords?\\s*:?.*?(?=\\n\\n|\\n[A-Z]|$)/gim, \"\");\n    // Remove page numbers and headers/footers\n    cleanedText = cleanedText.replace(/^\\s*\\d+\\s*$/gm, \"\") // Standalone page numbers\n    ;\n    cleanedText = cleanedText.replace(/^page \\d+.*$/gim, \"\") // \"Page X\" headers\n    ;\n    // Remove legal disclaimers and boilerplate\n    cleanedText = cleanedText.replace(/disclaimer.*?$/gim, \"\");\n    cleanedText = cleanedText.replace(/terms of use.*?$/gim, \"\");\n    cleanedText = cleanedText.replace(/privacy policy.*?$/gim, \"\");\n    // Remove excessive whitespace and normalize\n    cleanedText = cleanedText.replace(/\\n\\s*\\n\\s*\\n/g, \"\\n\\n\") // Multiple newlines to double\n    ;\n    cleanedText = cleanedText.replace(/^\\s+|\\s+$/gm, \"\") // Trim each line\n    ;\n    cleanedText = cleanedText.trim();\n    return cleanedText;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9hcHAvYXBpL2RldGVjdC1rZXl3b3Jkcy9yb3V0ZS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FpQkMsR0FFc0Q7QUFDNUI7QUFFM0Isc0RBQXNEO0FBQ3RELE1BQU1FLFNBQVMsSUFBSUQsOENBQU1BLENBQUM7SUFDeEJFLFFBQVFDLFFBQVFDLEdBQUcsQ0FBQ0MsY0FBYztBQUNwQztBQUVBOzs7Ozs7Ozs7Ozs7O0NBYUMsR0FDTSxlQUFlQyxLQUFLQyxPQUFvQjtJQUM3QyxJQUFJO1FBQ0YsTUFBTSxFQUFFQyxJQUFJLEVBQUUsR0FBRyxNQUFNRCxRQUFRRSxJQUFJO1FBRW5DLDBCQUEwQjtRQUMxQixJQUFJLENBQUNELE1BQU07WUFDVCxPQUFPVCxrRkFBWUEsQ0FBQ1UsSUFBSSxDQUFDO2dCQUFFQyxPQUFPO1lBQW1CLEdBQUc7Z0JBQUVDLFFBQVE7WUFBSTtRQUN4RTtRQUVBLDREQUE0RDtRQUM1RCxNQUFNQyxXQUFXLE1BQU1DLG9DQUFvQ0w7UUFFM0QsT0FBT1Qsa0ZBQVlBLENBQUNVLElBQUksQ0FBQztZQUFFRztRQUFTO0lBRXRDLEVBQUUsT0FBT0YsT0FBTztRQUNkSSxRQUFRSixLQUFLLENBQUMsNkJBQTZCQTtRQUMzQyxPQUFPWCxrRkFBWUEsQ0FBQ1UsSUFBSSxDQUN0QjtZQUFFQyxPQUFPO1FBQTRCLEdBQ3JDO1lBQUVDLFFBQVE7UUFBSTtJQUVsQjtBQUNGO0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBaUJDLEdBQ0QsZUFBZUUsb0NBQW9DTCxJQUFZO0lBQzdELE1BQU1JLFdBQW9FLEVBQUU7SUFDNUUsTUFBTUcsYUFBYSxJQUFJQztJQUV2Qiw0RUFBNEU7SUFDNUUsTUFBTUMsWUFBWUMsNkJBQTZCVjtJQUUvQyw0RUFBNEU7SUFDNUUsTUFBTVcsc0JBQXNCQywyQkFBMkJIO0lBRXZELDhFQUE4RTtJQUM5RSxNQUFNSSxhQUFhO1FBQ2pCLElBQU1DLHNCQUFzQkwsV0FBV0U7UUFDdkMsSUFBTUks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cyI6WyJ3ZWJwYWNrOi8vcGRmLWtleXdvcmQtYW5hbHl6ZXIvLi9hcHAvYXBpL2RldGVjdC1rZXl3b3Jkcy9yb3V0ZS50cz9iZDRkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQVBJIFJvdXRlOiBEZXRlY3QgS2V5d29yZHNcbiAqIFxuICogVGhpcyBBUEkgZW5kcG9pbnQgdXNlcyBhZHZhbmNlZCBzZW1hbnRpYyBhbmFseXNpcyB0byBkZXRlY3QgYW5kIGV4dHJhY3Qga2V5d29yZHNcbiAqIGZyb20gUERGIHRleHQgY29udGVudC4gSXQgZW1wbG95cyBtdWx0aXBsZSBzdHJhdGVnaWVzIGluY2x1ZGluZyB0ZWNobmljYWwgdGVybVxuICogZGV0ZWN0aW9uLCBmcmVxdWVuY3kgYW5hbHlzaXMsIGFuZCBjb250ZXh0dWFsIGltcG9ydGFuY2Ugc2NvcmluZy5cbiAqIFxuICogRmVhdHVyZXM6XG4gKiAtIFNlbWFudGljIGZpbmdlcnByaW50IGFuYWx5c2lzIGZvciBkb2N1bWVudCBzdHJ1Y3R1cmUgdW5kZXJzdGFuZGluZ1xuICogLSBNdWx0aS1zdHJhdGVneSBrZXl3b3JkIGV4dHJhY3Rpb24gKHRlY2huaWNhbCB0ZXJtcywgcGhyYXNlcywgZG9tYWluLXNwZWNpZmljKVxuICogLSBBSS1wb3dlcmVkIGRlZmluaXRpb24gZ2VuZXJhdGlvbiB1c2luZyBPcGVuQUkgR1BULTRcbiAqIC0gRmFsbGJhY2sgdG8gc2VtYW50aWMgYW5hbHlzaXMgd2hlbiBBSSBpcyB1bmF2YWlsYWJsZVxuICogLSBDb250ZXh0LWF3YXJlIGtleXdvcmQgc2NvcmluZyBhbmQgcmFua2luZ1xuICogXG4gKiBAZmlsZW92ZXJ2aWV3IEFQSSByb3V0ZSBmb3IgaW50ZWxsaWdlbnQga2V5d29yZCBkZXRlY3Rpb24gZnJvbSBQREYgdGV4dFxuICogQGF1dGhvciBQREYgS2V5d29yZCBBbmFseXplciBUZWFtXG4gKiBAdmVyc2lvbiAxLjAuMFxuICovXG5cbmltcG9ydCB7IE5leHRSZXF1ZXN0LCBOZXh0UmVzcG9uc2UgfSBmcm9tICduZXh0L3NlcnZlcidcbmltcG9ydCBPcGVuQUkgZnJvbSAnb3BlbmFpJ1xuXG4vLyBJbml0aWFsaXplIE9wZW5BSSBjbGllbnQgZm9yIEFJLXBvd2VyZWQgZGVmaW5pdGlvbnNcbmNvbnN0IG9wZW5haSA9IG5ldyBPcGVuQUkoe1xuICBhcGlLZXk6IHByb2Nlc3MuZW52Lk9QRU5BSV9BUElfS0VZLFxufSlcblxuLyoqXG4gKiBQT1NUIC9hcGkvZGV0ZWN0LWtleXdvcmRzXG4gKiBcbiAqIERldGVjdHMgYW5kIGV4dHJhY3RzIGtleXdvcmRzIGZyb20gUERGIHRleHQgdXNpbmcgc2VtYW50aWMgYW5hbHlzaXMuXG4gKiBcbiAqIFJlcXVlc3QgQm9keTpcbiAqIC0gdGV4dDogc3RyaW5nIC0gVGhlIGV4dHJhY3RlZCB0ZXh0IGNvbnRlbnQgZnJvbSBQREZcbiAqIFxuICogUmVzcG9uc2U6XG4gKiAtIGtleXdvcmRzOiBBcnJheSBvZiBrZXl3b3JkIG9iamVjdHMgd2l0aCB3b3JkLCBkZWZpbml0aW9uLCBjb250ZXh0LCBhbmQgaXNHUFQgZmxhZ1xuICogXG4gKiBAcGFyYW0gcmVxdWVzdCAtIE5leHQuanMgcmVxdWVzdCBvYmplY3QgY29udGFpbmluZyBQREYgdGV4dFxuICogQHJldHVybnMgSlNPTiByZXNwb25zZSB3aXRoIGRldGVjdGVkIGtleXdvcmRzIGFuZCB0aGVpciBkZWZpbml0aW9uc1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gUE9TVChyZXF1ZXN0OiBOZXh0UmVxdWVzdCkge1xuICB0cnkge1xuICAgIGNvbnN0IHsgdGV4dCB9ID0gYXdhaXQgcmVxdWVzdC5qc29uKClcblxuICAgIC8vIFZhbGlkYXRlIHJlcXVpcmVkIGlucHV0XG4gICAgaWYgKCF0ZXh0KSB7XG4gICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oeyBlcnJvcjogJ1RleHQgaXMgcmVxdWlyZWQnIH0sIHsgc3RhdHVzOiA0MDAgfSlcbiAgICB9XG5cbiAgICAvLyBVc2UgYWR2YW5jZWQgc2VtYW50aWMgZmluZ2VycHJpbnQtYmFzZWQga2V5d29yZCBkZXRlY3Rpb25cbiAgICBjb25zdCBrZXl3b3JkcyA9IGF3YWl0IHNlbWFudGljRmluZ2VycHJpbnRLZXl3b3JkRGV0ZWN0aW9uKHRleHQpXG4gICAgXG4gICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHsga2V5d29yZHMgfSlcblxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGRldGVjdGluZyBrZXl3b3JkczonLCBlcnJvcilcbiAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oXG4gICAgICB7IGVycm9yOiAnRmFpbGVkIHRvIGRldGVjdCBrZXl3b3JkcycgfSxcbiAgICAgIHsgc3RhdHVzOiA1MDAgfVxuICAgIClcbiAgfVxufVxuXG4vKipcbiAqIFNlbWFudGljIEZpbmdlcnByaW50IEtleXdvcmQgRGV0ZWN0aW9uXG4gKiBcbiAqIFRoaXMgaXMgdGhlIGNvcmUgZnVuY3Rpb24gdGhhdCBwZXJmb3JtcyBhZHZhbmNlZCBrZXl3b3JkIGRldGVjdGlvbiB1c2luZ1xuICogbXVsdGlwbGUgc2VtYW50aWMgYW5hbHlzaXMgc3RyYXRlZ2llcy4gSXQgY3JlYXRlcyBhIFwiZmluZ2VycHJpbnRcIiBvZiB0aGVcbiAqIGRvY3VtZW50IHRvIHVuZGVyc3RhbmQgaXRzIHN0cnVjdHVyZSBhbmQgY29udGVudCwgdGhlbiBhcHBsaWVzIHZhcmlvdXNcbiAqIGV4dHJhY3Rpb24gc3RyYXRlZ2llcyB0byBpZGVudGlmeSB0aGUgbW9zdCBpbXBvcnRhbnQgdGVybXMuXG4gKiBcbiAqIFByb2Nlc3M6XG4gKiAxLiBDbGVhbiBhbmQgcHJlcHJvY2VzcyB0aGUgdGV4dFxuICogMi4gQW5hbHl6ZSBkb2N1bWVudCBzdHJ1Y3R1cmUgYW5kIHNlbWFudGljIHBhdHRlcm5zXG4gKiAzLiBBcHBseSBtdWx0aXBsZSBleHRyYWN0aW9uIHN0cmF0ZWdpZXMgaW4gcGFyYWxsZWxcbiAqIDQuIFNjb3JlIGFuZCByYW5rIGtleXdvcmRzIGJ5IGltcG9ydGFuY2VcbiAqIDUuIEdlbmVyYXRlIEFJLXBvd2VyZWQgZGVmaW5pdGlvbnMgZm9yIHRvcCBrZXl3b3Jkc1xuICogXG4gKiBAcGFyYW0gdGV4dCAtIFJhdyB0ZXh0IGNvbnRlbnQgZnJvbSBQREZcbiAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIGFycmF5IG9mIGtleXdvcmQgb2JqZWN0cyB3aXRoIGRlZmluaXRpb25zXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHNlbWFudGljRmluZ2VycHJpbnRLZXl3b3JkRGV0ZWN0aW9uKHRleHQ6IHN0cmluZyk6IFByb21pc2U8QXJyYXk8eyB3b3JkOiBzdHJpbmc7IGRlZmluaXRpb246IHN0cmluZzsgY29udGV4dDogc3RyaW5nOyBpc0dQVDogYm9vbGVhbiB9Pj4ge1xuICBjb25zdCBrZXl3b3JkczogQXJyYXk8eyB3b3JkOiBzdHJpbmc7IGNvbnRleHQ6IHN0cmluZzsgc2NvcmU6IG51bWJlciB9PiA9IFtdXG4gIGNvbnN0IGZvdW5kVGVybXMgPSBuZXcgU2V0PHN0cmluZz4oKVxuICBcbiAgLy8gQ2xlYW4gdGhlIHRleHQgdG8gcmVtb3ZlIG5vbi1jb250ZW50IHNlY3Rpb25zIChyZWZlcmVuY2VzLCBoZWFkZXJzLCBldGMuKVxuICBjb25zdCBjbGVhblRleHQgPSBjbGVhblRleHRGb3JLZXl3b3JkRGV0ZWN0aW9uKHRleHQpXG4gIFxuICAvLyBDcmVhdGUgc2VtYW50aWMgZmluZ2VycHJpbnQgdG8gdW5kZXJzdGFuZCBkb2N1bWVudCBzdHJ1Y3R1cmUgYW5kIHBhdHRlcm5zXG4gIGNvbnN0IHNlbWFudGljRmluZ2VycHJpbnQgPSBhbmFseXplU2VtYW50aWNGaW5nZXJwcmludChjbGVhblRleHQpXG4gIFxuICAvLyBBcHBseSBtdWx0aXBsZSBleHRyYWN0aW9uIHN0cmF0ZWdpZXMgaW4gcGFyYWxsZWwgZm9yIGNvbXByZWhlbnNpdmUgY292ZXJhZ2VcbiAgY29uc3Qgc3RyYXRlZ2llcyA9IFtcbiAgICAoKSA9PiBleHRyYWN0VGVjaG5pY2FsVGVybXMoY2xlYW5UZXh0LCBzZW1hbnRpY0ZpbmdlcnByaW50KSxcbiAgICAoKSA9PiBleHRyYWN0RnJlcXVlbnRJbnRlZ3JhbFRlcm1zKGNsZWFuVGV4dCwgc2VtYW50aWNGaW5nZXJwcmludCksXG4gICAgKCkgPT4gZXh0cmFjdENvbnRleHR1YWxLZXl3b3JkcyhjbGVhblRleHQsIHNlbWFudGljRmluZ2VycHJpbnQpLFxuICAgICgpID0+IGV4dHJhY3REb21haW5TcGVjaWZpY1Rlcm1zKGNsZWFuVGV4dCwgc2VtYW50aWNGaW5nZXJwcmludCksXG4gICAgKCkgPT4gZXh0cmFjdFNlbWFudGljQ2x1c3RlcnMoY2xlYW5UZXh0LCBzZW1hbnRpY0ZpbmdlcnByaW50KSxcbiAgICAoKSA9PiBleHRyYWN0TXVsdGlXb3JkUGhyYXNlcyhjbGVhblRleHQsIHNlbWFudGljRmluZ2VycHJpbnQpXG4gIF1cbiAgXG4gIC8vIEV4ZWN1dGUgYWxsIHN0cmF0ZWdpZXMgYW5kIGNvbGxlY3QgdW5pcXVlIGtleXdvcmRzXG4gIHN0cmF0ZWdpZXMuZm9yRWFjaChzdHJhdGVneSA9PiB7XG4gICAgY29uc3QgZXh0cmFjdGVkS2V5d29yZHMgPSBzdHJhdGVneSgpXG4gICAgZXh0cmFjdGVkS2V5d29yZHMuZm9yRWFjaChrZXl3b3JkID0+IHtcbiAgICAgIGlmICghZm91bmRUZXJtcy5oYXMoa2V5d29yZC53b3JkLnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgICAgIGZvdW5kVGVybXMuYWRkKGtleXdvcmQud29yZC50b0xvd2VyQ2FzZSgpKVxuICAgICAgICBrZXl3b3Jkcy5wdXNoKGtleXdvcmQpXG4gICAgICB9XG4gICAgfSlcbiAgfSlcbiAgXG4gIC8vIFJlbW92ZSBkdXBsaWNhdGVzIGFuZCBzb3J0IGJ5IHNlbWFudGljIGltcG9ydGFuY2Ugc2NvcmVcbiAgY29uc3QgdW5pcXVlS2V5d29yZHMgPSBrZXl3b3Jkcy5maWx0ZXIoKGtleXdvcmQsIGluZGV4LCBzZWxmKSA9PiBcbiAgICBpbmRleCA9PT0gc2VsZi5maW5kSW5kZXgoayA9PiBrLndvcmQudG9Mb3dlckNhc2UoKSA9PT0ga2V5d29yZC53b3JkLnRvTG93ZXJDYXNlKCkpXG4gIClcbiAgXG4gIC8vIFNvcnQgYnkgc2VtYW50aWMgaW1wb3J0YW5jZSBzY29yZSAoaGlnaGVyIGlzIGJldHRlcilcbiAgdW5pcXVlS2V5d29yZHMuc29ydCgoYSwgYikgPT4gYi5zY29yZSAtIGEuc2NvcmUpXG4gIFxuICAvLyBHZW5lcmF0ZSBBSS1wb3dlcmVkIGRlZmluaXRpb25zIGZvciB0b3AgMjAga2V5d29yZHNcbiAgY29uc3Qga2V5d29yZHNXaXRoRGVmaW5pdGlvbnMgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICB1bmlxdWVLZXl3b3Jkcy5zbGljZSgwLCAyMCkubWFwKGFzeW5jIGsgPT4ge1xuICAgICAgY29uc3QgZGVmaW5pdGlvblJlc3VsdCA9IGF3YWl0IGdlbmVyYXRlRGVmaW5pdGlvbihrLndvcmQsIGNsZWFuVGV4dCwgc2VtYW50aWNGaW5nZXJwcmludClcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdvcmQ6IGsud29yZCxcbiAgICAgICAgZGVmaW5pdGlvbjogZGVmaW5pdGlvblJlc3VsdC5kZWZpbml0aW9uLFxuICAgICAgICBjb250ZXh0OiBrLmNvbnRleHQsXG4gICAgICAgIGlzR1BUOiBkZWZpbml0aW9uUmVzdWx0LmlzR1BUXG4gICAgICB9XG4gICAgfSlcbiAgKVxuICBcbiAgcmV0dXJuIGtleXdvcmRzV2l0aERlZmluaXRpb25zXG59XG5cbmZ1bmN0aW9uIGFuYWx5emVTZW1hbnRpY0ZpbmdlcnByaW50KHRleHQ6IHN0cmluZykge1xuICBjb25zdCBmaW5nZXJwcmludCA9IHtcbiAgICAvLyBEb2N1bWVudCBzdHJ1Y3R1cmUgYW5hbHlzaXNcbiAgICBzZWN0aW9uczogZXh0cmFjdERvY3VtZW50U2VjdGlvbnModGV4dCksXG4gICAgXG4gICAgLy8gV29yZCBmcmVxdWVuY3kgYW5hbHlzaXNcbiAgICB3b3JkRnJlcXVlbmNpZXM6IGNhbGN1bGF0ZVdvcmRGcmVxdWVuY2llcyh0ZXh0KSxcbiAgICBcbiAgICAvLyBUZWNobmljYWwgdGVybSBkZW5zaXR5XG4gICAgdGVjaG5pY2FsRGVuc2l0eTogY2FsY3VsYXRlVGVjaG5pY2FsRGVuc2l0eSh0ZXh0KSxcbiAgICBcbiAgICAvLyBTZW1hbnRpYyBjbHVzdGVyc1xuICAgIHNlbWFudGljQ2x1c3RlcnM6IGlkZW50aWZ5U2VtYW50aWNDbHVzdGVycyh0ZXh0KSxcbiAgICBcbiAgICAvLyBDb250ZXh0dWFsIGltcG9ydGFuY2VcbiAgICBjb250ZXh0dWFsSW1wb3J0YW5jZTogY2FsY3VsYXRlQ29udGV4dHVhbEltcG9ydGFuY2UodGV4dCksXG4gICAgXG4gICAgLy8gRG9tYWluIGluZGljYXRvcnNcbiAgICBkb21haW5JbmRpY2F0b3JzOiBpZGVudGlmeURvbWFpbkluZGljYXRvcnModGV4dClcbiAgfVxuICBcbiAgcmV0dXJuIGZpbmdlcnByaW50XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3REb2N1bWVudFNlY3Rpb25zKHRleHQ6IHN0cmluZykge1xuICBjb25zdCBzZWN0aW9ucyA9IHtcbiAgICBhYnN0cmFjdDogZXh0cmFjdFNlY3Rpb24odGV4dCwgL2Fic3RyYWN0XFxzKjo/L2kpLFxuICAgIGludHJvZHVjdGlvbjogZXh0cmFjdFNlY3Rpb24odGV4dCwgL2ludHJvZHVjdGlvblxccyo6Py9pKSxcbiAgICBtZXRob2RvbG9neTogZXh0cmFjdFNlY3Rpb24odGV4dCwgL21ldGhvZCg/Om9sb2d5fHMpP1xccyo6Py9pKSxcbiAgICByZXN1bHRzOiBleHRyYWN0U2VjdGlvbih0ZXh0LCAvcmVzdWx0cz9cXHMqOj8vaSksXG4gICAgZGlzY3Vzc2lvbjogZXh0cmFjdFNlY3Rpb24odGV4dCwgL2Rpc2N1c3Npb25cXHMqOj8vaSksXG4gICAgY29uY2x1c2lvbjogZXh0cmFjdFNlY3Rpb24odGV4dCwgL2NvbmNsdXNpb25cXHMqOj8vaSlcbiAgfVxuICBcbiAgcmV0dXJuIHNlY3Rpb25zXG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RTZWN0aW9uKHRleHQ6IHN0cmluZywgcGF0dGVybjogUmVnRXhwKTogc3RyaW5nIHtcbiAgY29uc3QgbWF0Y2ggPSB0ZXh0Lm1hdGNoKG5ldyBSZWdFeHAocGF0dGVybi5zb3VyY2UgKyAnKFtcXFxcc1xcXFxTXSo/KSg/PVxcXFxuXFxcXG5bQS1aXXxcXFxcbltBLVpdW2Etel0rXFxcXHMqOj98JCknLCAnaScpKVxuICByZXR1cm4gbWF0Y2ggPyBtYXRjaFsxXS50cmltKCkgOiAnJ1xufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVXb3JkRnJlcXVlbmNpZXModGV4dDogc3RyaW5nKTogeyBba2V5OiBzdHJpbmddOiBudW1iZXIgfSB7XG4gIGNvbnN0IHdvcmRzID0gdGV4dC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9cXGJbYS16QS1aXXszLH1cXGIvZykgfHwgW11cbiAgY29uc3QgZnJlcXVlbmNpZXM6IHsgW2tleTogc3RyaW5nXTogbnVtYmVyIH0gPSB7fVxuICBcbiAgd29yZHMuZm9yRWFjaCh3b3JkID0+IHtcbiAgICBmcmVxdWVuY2llc1t3b3JkXSA9IChmcmVxdWVuY2llc1t3b3JkXSB8fCAwKSArIDFcbiAgfSlcbiAgXG4gIHJldHVybiBmcmVxdWVuY2llc1xufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVUZWNobmljYWxEZW5zaXR5KHRleHQ6IHN0cmluZyk6IG51bWJlciB7XG4gIGNvbnN0IHRlY2huaWNhbFBhdHRlcm5zID0gW1xuICAgIC9cXGJcXHcqKD86b2xvZ3l8aXNtfHRpb258c2lvbnxtZW50fG5lc3N8aXR5fGl2ZXxpY2FsfGFibGV8aWJsZXxncmFwaHl8bWV0cnl8bm9teXxwYXRoeXxwaG9iaWF8cGhpbGlhfGl6YXRpb258aWZpY2F0aW9uKVxcYi9naSxcbiAgICAvXFxiW0EtWl17Miw2fVxcYi9nLFxuICAgIC9cXGJcXHcqXFxkK1xcdypcXGIvZ1xuICBdXG4gIFxuICBsZXQgdGVjaG5pY2FsQ291bnQgPSAwXG4gIHRlY2huaWNhbFBhdHRlcm5zLmZvckVhY2gocGF0dGVybiA9PiB7XG4gICAgY29uc3QgbWF0Y2hlcyA9IHRleHQubWF0Y2gocGF0dGVybilcbiAgICBpZiAobWF0Y2hlcykgdGVjaG5pY2FsQ291bnQgKz0gbWF0Y2hlcy5sZW5ndGhcbiAgfSlcbiAgXG4gIGNvbnN0IHRvdGFsV29yZHMgPSAodGV4dC5tYXRjaCgvXFxiXFx3K1xcYi9nKSB8fCBbXSkubGVuZ3RoXG4gIHJldHVybiB0b3RhbFdvcmRzID4gMCA/IHRlY2huaWNhbENvdW50IC8gdG90YWxXb3JkcyA6IDBcbn1cblxuZnVuY3Rpb24gaWRlbnRpZnlTZW1hbnRpY0NsdXN0ZXJzKHRleHQ6IHN0cmluZyk6IHN0cmluZ1tdW10ge1xuICAvLyBHcm91cCByZWxhdGVkIHRlcm1zIGJhc2VkIG9uIGNvLW9jY3VycmVuY2UgYW5kIHNlbWFudGljIHBhdHRlcm5zXG4gIGNvbnN0IGNsdXN0ZXJzOiBzdHJpbmdbXVtdID0gW11cbiAgXG4gIC8vIENvbW1vbiBzZW1hbnRpYyBjbHVzdGVycyBpbiBhY2FkZW1pYyBwYXBlcnNcbiAgY29uc3QgY2x1c3RlclBhdHRlcm5zID0gW1xuICAgIC8vIFJlc2VhcmNoIG1ldGhvZG9sb2d5IGNsdXN0ZXJcbiAgICBbJ3Jlc2VhcmNoJywgJ3N0dWR5JywgJ2V4cGVyaW1lbnQnLCAnbWV0aG9kJywgJ2FuYWx5c2lzJywgJ2RhdGEnLCAncmVzdWx0cycsICdmaW5kaW5ncyddLFxuICAgIC8vIFRlY2huaWNhbCBpbXBsZW1lbnRhdGlvbiBjbHVzdGVyXG4gICAgWydhbGdvcml0aG0nLCAnbW9kZWwnLCAnc3lzdGVtJywgJ2ZyYW1ld29yaycsICdhcHByb2FjaCcsICd0ZWNobmlxdWUnLCAnbWV0aG9kb2xvZ3knXSxcbiAgICAvLyBTdGF0aXN0aWNhbCBhbmFseXNpcyBjbHVzdGVyXG4gICAgWydzdGF0aXN0aWNhbCcsICdjb3JyZWxhdGlvbicsICdyZWdyZXNzaW9uJywgJ3NpZ25pZmljYW5jZScsICdoeXBvdGhlc2lzJywgJ3AtdmFsdWUnLCAnY29uZmlkZW5jZSddLFxuICAgIC8vIE1hY2hpbmUgbGVhcm5pbmcgY2x1c3RlclxuICAgIFsnbWFjaGluZScsICdsZWFybmluZycsICduZXVyYWwnLCAnbmV0d29yaycsICdhcnRpZmljaWFsJywgJ2ludGVsbGlnZW5jZScsICdhbGdvcml0aG0nLCAnbW9kZWwnXSxcbiAgICAvLyBQZXJmb3JtYW5jZSBldmFsdWF0aW9uIGNsdXN0ZXJcbiAgICBbJ3BlcmZvcm1hbmNlJywgJ2FjY3VyYWN5JywgJ2VmZmljaWVuY3knLCAnZXZhbHVhdGlvbicsICdhc3Nlc3NtZW50JywgJ21lYXN1cmVtZW50JywgJ2JlbmNobWFyayddXG4gIF1cbiAgXG4gIGNsdXN0ZXJQYXR0ZXJucy5mb3JFYWNoKGNsdXN0ZXIgPT4ge1xuICAgIGNvbnN0IGZvdW5kVGVybXMgPSBjbHVzdGVyLmZpbHRlcih0ZXJtID0+IFxuICAgICAgbmV3IFJlZ0V4cChgXFxcXGIke3Rlcm19XFxcXGJgLCAnaScpLnRlc3QodGV4dClcbiAgICApXG4gICAgaWYgKGZvdW5kVGVybXMubGVuZ3RoID49IDIpIHtcbiAgICAgIGNsdXN0ZXJzLnB1c2goZm91bmRUZXJtcylcbiAgICB9XG4gIH0pXG4gIFxuICByZXR1cm4gY2x1c3RlcnNcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlQ29udGV4dHVhbEltcG9ydGFuY2UodGV4dDogc3RyaW5nKTogeyBba2V5OiBzdHJpbmddOiBudW1iZXIgfSB7XG4gIGNvbnN0IGltcG9ydGFuY2U6IHsgW2tleTogc3RyaW5nXTogbnVtYmVyIH0gPSB7fVxuICBcbiAgLy8gVGVybXMgdGhhdCBhcHBlYXIgaW4gbXVsdGlwbGUgc2VjdGlvbnMgYXJlIG1vcmUgaW1wb3J0YW50XG4gIGNvbnN0IHNlY3Rpb25zID0gZXh0cmFjdERvY3VtZW50U2VjdGlvbnModGV4dClcbiAgY29uc3QgYWxsU2VjdGlvblRleHQgPSBPYmplY3QudmFsdWVzKHNlY3Rpb25zKS5qb2luKCcgJylcbiAgXG4gIC8vIENhbGN1bGF0ZSBpbXBvcnRhbmNlIGJhc2VkIG9uIHNlY3Rpb24gcHJlc2VuY2UgYW5kIGZyZXF1ZW5jeVxuICBjb25zdCB3b3JkcyA9IGFsbFNlY3Rpb25UZXh0LnRvTG93ZXJDYXNlKCkubWF0Y2goL1xcYlthLXpBLVpdezQsfVxcYi9nKSB8fCBbXVxuICBjb25zdCB3b3JkQ291bnRzOiB7IFtrZXk6IHN0cmluZ106IG51bWJlciB9ID0ge31cbiAgXG4gIHdvcmRzLmZvckVhY2god29yZCA9PiB7XG4gICAgd29yZENvdW50c1t3b3JkXSA9ICh3b3JkQ291bnRzW3dvcmRdIHx8IDApICsgMVxuICB9KVxuICBcbiAgT2JqZWN0LmVudHJpZXMod29yZENvdW50cykuZm9yRWFjaCgoW3dvcmQsIGNvdW50XSkgPT4ge1xuICAgIC8vIEltcG9ydGFuY2Ugc2NvcmUgYmFzZWQgb24gZnJlcXVlbmN5IGFuZCBzZWN0aW9uIGRpdmVyc2l0eVxuICAgIGxldCBzY29yZSA9IGNvdW50XG4gICAgT2JqZWN0LnZhbHVlcyhzZWN0aW9ucykuZm9yRWFjaChzZWN0aW9uID0+IHtcbiAgICAgIGlmIChzZWN0aW9uLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMod29yZCkpIHtcbiAgICAgICAgc2NvcmUgKz0gMVxuICAgICAgfVxuICAgIH0pXG4gICAgaW1wb3J0YW5jZVt3b3JkXSA9IHNjb3JlXG4gIH0pXG4gIFxuICByZXR1cm4gaW1wb3J0YW5jZVxufVxuXG5mdW5jdGlvbiBpZGVudGlmeURvbWFpbkluZGljYXRvcnModGV4dDogc3RyaW5nKTogc3RyaW5nW10ge1xuICBjb25zdCBkb21haW5QYXR0ZXJucyA9IFtcbiAgICAvLyBDb21wdXRlciBTY2llbmNlXG4gICAgL1xcYig/OmFsZ29yaXRobXxwcm9ncmFtbWluZ3xzb2Z0d2FyZXxoYXJkd2FyZXxkYXRhYmFzZXxuZXR3b3JrfHNlY3VyaXR5fGFydGlmaWNpYWx8aW50ZWxsaWdlbmNlfG1hY2hpbmV8bGVhcm5pbmcpXFxiL2dpLFxuICAgIC8vIE1lZGljaW5lL0Jpb2xvZ3lcbiAgICAvXFxiKD86cGF0aWVudHxjbGluaWNhbHxtZWRpY2FsfGJpb2xvZ2ljYWx8Z2VuZXRpY3xwcm90ZWlufGNlbGx8ZGlzZWFzZXx0cmVhdG1lbnR8dGhlcmFweSlcXGIvZ2ksXG4gICAgLy8gUHN5Y2hvbG9neVxuICAgIC9cXGIoPzpwc3ljaG9sb2dpY2FsfGJlaGF2aW9yfGNvZ25pdGl2ZXxtZW50YWx8dGhlcmFweXxjb3Vuc2VsaW5nfGFzc2Vzc21lbnR8cGVyc29uYWxpdHkpXFxiL2dpLFxuICAgIC8vIEVjb25vbWljc1xuICAgIC9cXGIoPzplY29ub21pY3xmaW5hbmNpYWx8bWFya2V0fGludmVzdG1lbnR8cmV2ZW51ZXxwcm9maXR8Y29zdHxwcmljZXxkZW1hbmR8c3VwcGx5KVxcYi9naSxcbiAgICAvLyBQaHlzaWNzXG4gICAgL1xcYig/OnF1YW50dW18cGFydGljbGV8ZW5lcmd5fGZvcmNlfG1vdGlvbnx3YXZlfGZpZWxkfGVsZWN0cm9tYWduZXRpY3xudWNsZWFyfGF0b21pYylcXGIvZ2lcbiAgXVxuICBcbiAgY29uc3QgZG9tYWluczogc3RyaW5nW10gPSBbXVxuICBkb21haW5QYXR0ZXJucy5mb3JFYWNoKChwYXR0ZXJuLCBpbmRleCkgPT4ge1xuICAgIGNvbnN0IG1hdGNoZXMgPSB0ZXh0Lm1hdGNoKHBhdHRlcm4pXG4gICAgaWYgKG1hdGNoZXMgJiYgbWF0Y2hlcy5sZW5ndGggPiAzKSB7XG4gICAgICBjb25zdCBkb21haW5OYW1lcyA9IFsnQ29tcHV0ZXIgU2NpZW5jZScsICdNZWRpY2luZS9CaW9sb2d5JywgJ1BzeWNob2xvZ3knLCAnRWNvbm9taWNzJywgJ1BoeXNpY3MnXVxuICAgICAgZG9tYWlucy5wdXNoKGRvbWFpbk5hbWVzW2luZGV4XSlcbiAgICB9XG4gIH0pXG4gIFxuICByZXR1cm4gZG9tYWluc1xufVxuXG5mdW5jdGlvbiBleHRyYWN0VGVjaG5pY2FsVGVybXModGV4dDogc3RyaW5nLCBmaW5nZXJwcmludDogYW55KTogQXJyYXk8eyB3b3JkOiBzdHJpbmc7IGNvbnRleHQ6IHN0cmluZzsgc2NvcmU6IG51bWJlciB9PiB7XG4gIGNvbnN0IGtleXdvcmRzOiBBcnJheTx7IHdvcmQ6IHN0cmluZzsgY29udGV4dDogc3RyaW5nOyBzY29yZTogbnVtYmVyIH0+ID0gW11cbiAgXG4gIGNvbnN0IHRlY2huaWNhbFBhdHRlcm5zID0gW1xuICAgIC8vIEFjcm9ueW1zXG4gICAgeyBwYXR0ZXJuOiAvXFxiW0EtWl17Miw2fVxcYi9nLCB3ZWlnaHQ6IDAuOSB9LFxuICAgIC8vIFRlY2huaWNhbCBzdWZmaXhlc1xuICAgIHsgcGF0dGVybjogL1xcYlxcdyooPzpvbG9neXxpc218dGlvbnxzaW9ufG1lbnR8bmVzc3xpdHl8aXZlfGljYWx8YWJsZXxpYmxlfGdyYXBoeXxtZXRyeXxub215fHBhdGh5fHBob2JpYXxwaGlsaWF8aXphdGlvbnxpZmljYXRpb24pXFxiL2dpLCB3ZWlnaHQ6IDAuOCB9LFxuICAgIC8vIFNjaWVudGlmaWMgbm90YXRpb25cbiAgICB7IHBhdHRlcm46IC9cXGJcXHcqXFxkK1xcdypcXGIvZywgd2VpZ2h0OiAwLjcgfSxcbiAgICAvLyBDb21wb3VuZCB0ZXJtc1xuICAgIHsgcGF0dGVybjogL1xcYlxcdysoPzotfF8pXFx3K1xcYi9nLCB3ZWlnaHQ6IDAuNiB9XG4gIF1cbiAgXG4gIHRlY2huaWNhbFBhdHRlcm5zLmZvckVhY2goKHsgcGF0dGVybiwgd2VpZ2h0IH0pID0+IHtcbiAgICBjb25zdCBtYXRjaGVzID0gdGV4dC5tYXRjaChwYXR0ZXJuKVxuICAgIGlmIChtYXRjaGVzKSB7XG4gICAgICBtYXRjaGVzLmZvckVhY2gobWF0Y2ggPT4ge1xuICAgICAgICBpZiAobWF0Y2gubGVuZ3RoID4gMiAmJiAhaXNDb21tb25Xb3JkKG1hdGNoKSkge1xuICAgICAgICAgIGtleXdvcmRzLnB1c2goe1xuICAgICAgICAgICAgd29yZDogbWF0Y2gsXG4gICAgICAgICAgICBjb250ZXh0OiBleHRyYWN0Q29udGV4dCh0ZXh0LCBtYXRjaCksXG4gICAgICAgICAgICBzY29yZTogd2VpZ2h0ICogKGZpbmdlcnByaW50LndvcmRGcmVxdWVuY2llc1ttYXRjaC50b0xvd2VyQ2FzZSgpXSB8fCAxKVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9KVxuICBcbiAgcmV0dXJuIGtleXdvcmRzXG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RGcmVxdWVudEludGVncmFsVGVybXModGV4dDogc3RyaW5nLCBmaW5nZXJwcmludDogYW55KTogQXJyYXk8eyB3b3JkOiBzdHJpbmc7IGNvbnRleHQ6IHN0cmluZzsgc2NvcmU6IG51bWJlciB9PiB7XG4gIGNvbnN0IGtleXdvcmRzOiBBcnJheTx7IHdvcmQ6IHN0cmluZzsgY29udGV4dDogc3RyaW5nOyBzY29yZTogbnVtYmVyIH0+ID0gW11cbiAgXG4gIE9iamVjdC5lbnRyaWVzKGZpbmdlcnByaW50LndvcmRGcmVxdWVuY2llcykuZm9yRWFjaCgoW3dvcmQsIGNvdW50XSkgPT4ge1xuICAgIGNvbnN0IGZyZXF1ZW5jeSA9IGNvdW50IGFzIG51bWJlclxuICAgIGlmIChmcmVxdWVuY3kgPj0gMyAmJiB3b3JkLmxlbmd0aCA+IDMgJiYgIWlzQ29tbW9uV29yZCh3b3JkKSkge1xuICAgICAgY29uc3QgY29udGV4dHVhbFNjb3JlID0gZmluZ2VycHJpbnQuY29udGV4dHVhbEltcG9ydGFuY2Vbd29yZF0gfHwgZnJlcXVlbmN5XG4gICAgICBrZXl3b3Jkcy5wdXNoKHtcbiAgICAgICAgd29yZDogd29yZC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHdvcmQuc2xpY2UoMSksXG4gICAgICAgIGNvbnRleHQ6IGV4dHJhY3RDb250ZXh0KHRleHQsIHdvcmQpLFxuICAgICAgICBzY29yZTogY29udGV4dHVhbFNjb3JlICogMC41XG4gICAgICB9KVxuICAgIH1cbiAgfSlcbiAgXG4gIHJldHVybiBrZXl3b3Jkc1xufVxuXG5mdW5jdGlvbiBleHRyYWN0Q29udGV4dHVhbEtleXdvcmRzKHRleHQ6IHN0cmluZywgZmluZ2VycHJpbnQ6IGFueSk6IEFycmF5PHsgd29yZDogc3RyaW5nOyBjb250ZXh0OiBzdHJpbmc7IHNjb3JlOiBudW1iZXIgfT4ge1xuICBjb25zdCBrZXl3b3JkczogQXJyYXk8eyB3b3JkOiBzdHJpbmc7IGNvbnRleHQ6IHN0cmluZzsgc2NvcmU6IG51bWJlciB9PiA9IFtdXG4gIFxuICAvLyBFeHRyYWN0IHRlcm1zIHRoYXQgYXBwZWFyIGluIG11bHRpcGxlIHNlY3Rpb25zXG4gIGNvbnN0IHNlY3Rpb25UZXJtczogeyBba2V5OiBzdHJpbmddOiBudW1iZXIgfSA9IHt9XG4gIFxuICBPYmplY3QuZW50cmllcyhmaW5nZXJwcmludC5zZWN0aW9ucykuZm9yRWFjaCgoW3NlY3Rpb25OYW1lLCBzZWN0aW9uVGV4dF0pID0+IHtcbiAgICBpZiAoc2VjdGlvblRleHQgJiYgdHlwZW9mIHNlY3Rpb25UZXh0ID09PSAnc3RyaW5nJykge1xuICAgICAgY29uc3Qgd29yZHMgPSBzZWN0aW9uVGV4dC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9cXGJbYS16QS1aXXs0LH1cXGIvZykgfHwgW11cbiAgICAgIHdvcmRzLmZvckVhY2goKHdvcmQ6IHN0cmluZykgPT4ge1xuICAgICAgICBpZiAoIWlzQ29tbW9uV29yZCh3b3JkKSkge1xuICAgICAgICAgIHNlY3Rpb25UZXJtc1t3b3JkXSA9IChzZWN0aW9uVGVybXNbd29yZF0gfHwgMCkgKyAxXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9KVxuICBcbiAgT2JqZWN0LmVudHJpZXMoc2VjdGlvblRlcm1zKS5mb3JFYWNoKChbd29yZCwgc2VjdGlvbkNvdW50XSkgPT4ge1xuICAgIGlmIChzZWN0aW9uQ291bnQgPj0gMikge1xuICAgICAga2V5d29yZHMucHVzaCh7XG4gICAgICAgIHdvcmQ6IHdvcmQuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyB3b3JkLnNsaWNlKDEpLFxuICAgICAgICBjb250ZXh0OiBleHRyYWN0Q29udGV4dCh0ZXh0LCB3b3JkKSxcbiAgICAgICAgc2NvcmU6IHNlY3Rpb25Db3VudCAqIDAuN1xuICAgICAgfSlcbiAgICB9XG4gIH0pXG4gIFxuICByZXR1cm4ga2V5d29yZHNcbn1cblxuZnVuY3Rpb24gZXh0cmFjdERvbWFpblNwZWNpZmljVGVybXModGV4dDogc3RyaW5nLCBmaW5nZXJwcmludDogYW55KTogQXJyYXk8eyB3b3JkOiBzdHJpbmc7IGNvbnRleHQ6IHN0cmluZzsgc2NvcmU6IG51bWJlciB9PiB7XG4gIGNvbnN0IGtleXdvcmRzOiBBcnJheTx7IHdvcmQ6IHN0cmluZzsgY29udGV4dDogc3RyaW5nOyBzY29yZTogbnVtYmVyIH0+ID0gW11cbiAgXG4gIC8vIERvbWFpbi1zcGVjaWZpYyB0ZXJtIHBhdHRlcm5zXG4gIGNvbnN0IGRvbWFpblRlcm1zID0gW1xuICAgIC8vIFJlc2VhcmNoIHRlcm1zXG4gICAgJ2h5cG90aGVzaXMnLCAnbWV0aG9kb2xvZ3knLCAnZW1waXJpY2FsJywgJ3F1YW50aXRhdGl2ZScsICdxdWFsaXRhdGl2ZScsICdsb25naXR1ZGluYWwnLCAnY3Jvc3Mtc2VjdGlvbmFsJyxcbiAgICAvLyBTdGF0aXN0aWNhbCB0ZXJtc1xuICAgICdjb3JyZWxhdGlvbicsICdyZWdyZXNzaW9uJywgJ3NpZ25pZmljYW5jZScsICdwLXZhbHVlJywgJ2NvbmZpZGVuY2UnLCAnaW50ZXJ2YWwnLCAnZWZmZWN0JywgJ3NpemUnLFxuICAgIC8vIFRlY2huaWNhbCB0ZXJtc1xuICAgICdhbGdvcml0aG0nLCAnb3B0aW1pemF0aW9uJywgJ2ltcGxlbWVudGF0aW9uJywgJ2V2YWx1YXRpb24nLCAnYmVuY2htYXJrJywgJ3BlcmZvcm1hbmNlJywgJ2FjY3VyYWN5JyxcbiAgICAvLyBTY2llbnRpZmljIHRlcm1zXG4gICAgJ2V4cGVyaW1lbnQnLCAnb2JzZXJ2YXRpb24nLCAnbWVhc3VyZW1lbnQnLCAnYW5hbHlzaXMnLCAnc3ludGhlc2lzJywgJ3ZhbGlkYXRpb24nLCAndmVyaWZpY2F0aW9uJ1xuICBdXG4gIFxuICBkb21haW5UZXJtcy5mb3JFYWNoKHRlcm0gPT4ge1xuICAgIGNvbnN0IHJlZ2V4ID0gbmV3IFJlZ0V4cChgXFxcXGIke3Rlcm19XFxcXGJgLCAnZ2knKVxuICAgIGNvbnN0IG1hdGNoZXMgPSB0ZXh0Lm1hdGNoKHJlZ2V4KVxuICAgIGlmIChtYXRjaGVzICYmIG1hdGNoZXMubGVuZ3RoID4gMCkge1xuICAgICAga2V5d29yZHMucHVzaCh7XG4gICAgICAgIHdvcmQ6IHRlcm0uY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyB0ZXJtLnNsaWNlKDEpLFxuICAgICAgICBjb250ZXh0OiBleHRyYWN0Q29udGV4dCh0ZXh0LCB0ZXJtKSxcbiAgICAgICAgc2NvcmU6IG1hdGNoZXMubGVuZ3RoICogMC42XG4gICAgICB9KVxuICAgIH1cbiAgfSlcbiAgXG4gIHJldHVybiBrZXl3b3Jkc1xufVxuXG5mdW5jdGlvbiBleHRyYWN0U2VtYW50aWNDbHVzdGVycyh0ZXh0OiBzdHJpbmcsIGZpbmdlcnByaW50OiBhbnkpOiBBcnJheTx7IHdvcmQ6IHN0cmluZzsgY29udGV4dDogc3RyaW5nOyBzY29yZTogbnVtYmVyIH0+IHtcbiAgY29uc3Qga2V5d29yZHM6IEFycmF5PHsgd29yZDogc3RyaW5nOyBjb250ZXh0OiBzdHJpbmc7IHNjb3JlOiBudW1iZXIgfT4gPSBbXVxuICBcbiAgZmluZ2VycHJpbnQuc2VtYW50aWNDbHVzdGVycy5mb3JFYWNoKChjbHVzdGVyOiBzdHJpbmdbXSkgPT4ge1xuICAgIGNsdXN0ZXIuZm9yRWFjaCh0ZXJtID0+IHtcbiAgICAgIGNvbnN0IHJlZ2V4ID0gbmV3IFJlZ0V4cChgXFxcXGIke3Rlcm19XFxcXGJgLCAnZ2knKVxuICAgICAgY29uc3QgbWF0Y2hlcyA9IHRleHQubWF0Y2gocmVnZXgpXG4gICAgICBpZiAobWF0Y2hlcyAmJiBtYXRjaGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAga2V5d29yZHMucHVzaCh7XG4gICAgICAgICAgd29yZDogdGVybS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHRlcm0uc2xpY2UoMSksXG4gICAgICAgICAgY29udGV4dDogZXh0cmFjdENvbnRleHQodGV4dCwgdGVybSksXG4gICAgICAgICAgc2NvcmU6IG1hdGNoZXMubGVuZ3RoICogMC40XG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfSlcbiAgfSlcbiAgXG4gIHJldHVybiBrZXl3b3Jkc1xufVxuXG5mdW5jdGlvbiBleHRyYWN0TXVsdGlXb3JkUGhyYXNlcyh0ZXh0OiBzdHJpbmcsIGZpbmdlcnByaW50OiBhbnkpOiBBcnJheTx7IHdvcmQ6IHN0cmluZzsgY29udGV4dDogc3RyaW5nOyBzY29yZTogbnVtYmVyIH0+IHtcbiAgY29uc3Qga2V5d29yZHM6IEFycmF5PHsgd29yZDogc3RyaW5nOyBjb250ZXh0OiBzdHJpbmc7IHNjb3JlOiBudW1iZXIgfT4gPSBbXVxuICBcbiAgLy8gQ29tbW9uIG11bHRpLXdvcmQgdGVjaG5pY2FsIHBocmFzZXNcbiAgY29uc3QgcGhyYXNlUGF0dGVybnMgPSBbXG4gICAgLy8gU2NpZW50aWZpYyBwaHJhc2VzXG4gICAgeyBwYXR0ZXJuOiAvXFxiKD86ZGVlcCBzZWF8Y2VsbCBkZWF0aHxwcm90ZWluIHN5bnRoZXNpc3xETkEgcmVwbGljYXRpb258Z2VuZSBleHByZXNzaW9ufGNlbGwgZGl2aXNpb258aW1tdW5lIHJlc3BvbnNlfG5ldXJhbCBuZXR3b3JrfG1hY2hpbmUgbGVhcm5pbmd8YXJ0aWZpY2lhbCBpbnRlbGxpZ2VuY2V8ZGF0YSBhbmFseXNpc3xzdGF0aXN0aWNhbCBzaWduaWZpY2FuY2V8Y29udHJvbCBncm91cHxleHBlcmltZW50YWwgZGVzaWduKVxcYi9naSwgd2VpZ2h0OiAwLjkgfSxcbiAgICAvLyBNZWRpY2FsL0Jpb2xvZ2ljYWwgcGhyYXNlc1xuICAgIHsgcGF0dGVybjogL1xcYig/OmJsb29kIHByZXNzdXJlfGhlYXJ0IHJhdGV8YnJhaW4gZnVuY3Rpb258bXVzY2xlIGNvbnRyYWN0aW9ufGVuenltZSBhY3Rpdml0eXxob3Jtb25lIGxldmVsc3xpbW11bmUgc3lzdGVtfG5lcnZvdXMgc3lzdGVtfGNhcmRpb3Zhc2N1bGFyIHN5c3RlbXxyZXNwaXJhdG9yeSBzeXN0ZW0pXFxiL2dpLCB3ZWlnaHQ6IDAuOSB9LFxuICAgIC8vIFRlY2huaWNhbCBwaHJhc2VzXG4gICAgeyBwYXR0ZXJuOiAvXFxiKD86dXNlciBpbnRlcmZhY2V8ZGF0YWJhc2UgbWFuYWdlbWVudHxuZXR3b3JrIHNlY3VyaXR5fHNvZnR3YXJlIGRldmVsb3BtZW50fGhhcmR3YXJlIGNvbmZpZ3VyYXRpb258ZGF0YSBwcm9jZXNzaW5nfGFsZ29yaXRobSBkZXNpZ258c3lzdGVtIGFyY2hpdGVjdHVyZXxjbG91ZCBjb21wdXRpbmd8bW9iaWxlIGFwcGxpY2F0aW9uKVxcYi9naSwgd2VpZ2h0OiAwLjggfSxcbiAgICAvLyBBY2FkZW1pYyBwaHJhc2VzXG4gICAgeyBwYXR0ZXJuOiAvXFxiKD86cmVzZWFyY2ggbWV0aG9kb2xvZ3l8bGl0ZXJhdHVyZSByZXZpZXd8ZGF0YSBjb2xsZWN0aW9ufHN0YXRpc3RpY2FsIGFuYWx5c2lzfGh5cG90aGVzaXMgdGVzdGluZ3xwZWVyIHJldmlld3xhY2FkZW1pYyB3cml0aW5nfHRoZW9yZXRpY2FsIGZyYW1ld29ya3xlbXBpcmljYWwgZXZpZGVuY2V8cXVhbGl0YXRpdmUgcmVzZWFyY2h8cXVhbnRpdGF0aXZlIHJlc2VhcmNoKVxcYi9naSwgd2VpZ2h0OiAwLjggfSxcbiAgICAvLyBHZW5lcmFsIGNvbXBvdW5kIHRlcm1zXG4gICAgeyBwYXR0ZXJuOiAvXFxiKD86aGlnaCBzY2hvb2x8bWlkZGxlIHNjaG9vbHxlbGVtZW50YXJ5IHNjaG9vbHx1bml2ZXJzaXR5IGxldmVsfGdyYWR1YXRlIGxldmVsfHVuZGVyZ3JhZHVhdGUgbGV2ZWx8cG9zdCBncmFkdWF0ZXxkb2N0b3JhbCBkZWdyZWV8bWFzdGVyJ3MgZGVncmVlfGJhY2hlbG9yJ3MgZGVncmVlKVxcYi9naSwgd2VpZ2h0OiAwLjcgfSxcbiAgICAvLyBUaW1lLXJlbGF0ZWQgcGhyYXNlc1xuICAgIHsgcGF0dGVybjogL1xcYig/OmxvbmcgdGVybXxzaG9ydCB0ZXJtfG1lZGl1bSB0ZXJtfHJlYWwgdGltZXxvdmVyIHRpbWV8aW4gdGltZXxvbiB0aW1lfGF0IHRoZSB0aW1lfGZvciB0aGUgdGltZXxkdXJpbmcgdGhlIHRpbWUpXFxiL2dpLCB3ZWlnaHQ6IDAuNiB9LFxuICAgIC8vIExvY2F0aW9uIHBocmFzZXNcbiAgICB7IHBhdHRlcm46IC9cXGIoPzpub3J0aCBhbWVyaWNhfHNvdXRoIGFtZXJpY2F8ZXVyb3BlYW4gdW5pb258bWlkZGxlIGVhc3R8ZmFyIGVhc3R8Y2VudHJhbCBhc2lhfHNvdXRoZWFzdCBhc2lhfHN1YiBzYWhhcmFufGxhdGluIGFtZXJpY2F8bm9ydGggYWZyaWNhKVxcYi9naSwgd2VpZ2h0OiAwLjYgfVxuICBdXG4gIFxuICBwaHJhc2VQYXR0ZXJucy5mb3JFYWNoKCh7IHBhdHRlcm4sIHdlaWdodCB9KSA9PiB7XG4gICAgY29uc3QgbWF0Y2hlcyA9IHRleHQubWF0Y2gocGF0dGVybilcbiAgICBpZiAobWF0Y2hlcykge1xuICAgICAgbWF0Y2hlcy5mb3JFYWNoKG1hdGNoID0+IHtcbiAgICAgICAgY29uc3QgcGhyYXNlID0gbWF0Y2gudHJpbSgpXG4gICAgICAgIGlmIChwaHJhc2UubGVuZ3RoID4gMyAmJiAhaXNDb21tb25QaHJhc2UocGhyYXNlKSkge1xuICAgICAgICAgIGtleXdvcmRzLnB1c2goe1xuICAgICAgICAgICAgd29yZDogcGhyYXNlLFxuICAgICAgICAgICAgY29udGV4dDogZXh0cmFjdENvbnRleHQodGV4dCwgcGhyYXNlKSxcbiAgICAgICAgICAgIHNjb3JlOiB3ZWlnaHQgKiAoZmluZ2VycHJpbnQud29yZEZyZXF1ZW5jaWVzW3BocmFzZS50b0xvd2VyQ2FzZSgpXSB8fCAxKVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9KVxuXG4gIC8vIEV4dHJhY3QgY3VzdG9tIHBocmFzZXMgZnJvbSB0aGUgZG9jdW1lbnQgKDItNCB3b3JkIGNvbWJpbmF0aW9ucyB0aGF0IGFwcGVhciBmcmVxdWVudGx5KVxuICBjb25zdCB3b3JkcyA9IHRleHQudG9Mb3dlckNhc2UoKS5tYXRjaCgvXFxiW2EtekEtWl17Myx9XFxiL2cpIHx8IFtdXG4gIGNvbnN0IHBocmFzZUNvdW50czogeyBba2V5OiBzdHJpbmddOiBudW1iZXIgfSA9IHt9XG4gIFxuICAvLyBMb29rIGZvciAyLXdvcmQgcGhyYXNlc1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHdvcmRzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgIGNvbnN0IHBocmFzZSA9IGAke3dvcmRzW2ldfSAke3dvcmRzW2kgKyAxXX1gXG4gICAgaWYgKCFpc0NvbW1vblBocmFzZShwaHJhc2UpKSB7XG4gICAgICBwaHJhc2VDb3VudHNbcGhyYXNlXSA9IChwaHJhc2VDb3VudHNbcGhyYXNlXSB8fCAwKSArIDFcbiAgICB9XG4gIH1cbiAgXG4gIC8vIExvb2sgZm9yIDMtd29yZCBwaHJhc2VzXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgd29yZHMubGVuZ3RoIC0gMjsgaSsrKSB7XG4gICAgY29uc3QgcGhyYXNlID0gYCR7d29yZHNbaV19ICR7d29yZHNbaSArIDFdfSAke3dvcmRzW2kgKyAyXX1gXG4gICAgaWYgKCFpc0NvbW1vblBocmFzZShwaHJhc2UpKSB7XG4gICAgICBwaHJhc2VDb3VudHNbcGhyYXNlXSA9IChwaHJhc2VDb3VudHNbcGhyYXNlXSB8fCAwKSArIDFcbiAgICB9XG4gIH1cbiAgXG4gIC8vIEFkZCBmcmVxdWVudCBjdXN0b20gcGhyYXNlc1xuICBPYmplY3QuZW50cmllcyhwaHJhc2VDb3VudHMpLmZvckVhY2goKFtwaHJhc2UsIGNvdW50XSkgPT4ge1xuICAgIGlmIChjb3VudCA+PSAyICYmIHBocmFzZS5sZW5ndGggPiA1KSB7XG4gICAgICBrZXl3b3Jkcy5wdXNoKHtcbiAgICAgICAgd29yZDogcGhyYXNlLnNwbGl0KCcgJykubWFwKHdvcmQgPT4gd29yZC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHdvcmQuc2xpY2UoMSkpLmpvaW4oJyAnKSxcbiAgICAgICAgY29udGV4dDogZXh0cmFjdENvbnRleHQodGV4dCwgcGhyYXNlKSxcbiAgICAgICAgc2NvcmU6IGNvdW50ICogMC41XG4gICAgICB9KVxuICAgIH1cbiAgfSlcbiAgXG4gIHJldHVybiBrZXl3b3Jkc1xufVxuXG5mdW5jdGlvbiBpc0NvbW1vblBocmFzZShwaHJhc2U6IHN0cmluZyk6IGJvb2xlYW4ge1xuICBjb25zdCBjb21tb25QaHJhc2VzID0gW1xuICAgICd0aGUgc2FtZScsICdpbiB0aGUnLCAnb24gdGhlJywgJ2F0IHRoZScsICdmb3IgdGhlJywgJ3dpdGggdGhlJywgJ3RvIHRoZScsICdvZiB0aGUnLCAnYW5kIHRoZScsICdvciB0aGUnLFxuICAgICd0aGlzIGlzJywgJ3RoYXQgaXMnLCAndGhlcmUgaXMnLCAndGhlcmUgYXJlJywgJ2l0IGlzJywgJ2l0IHdhcycsICdpdCBoYXMnLCAnaXQgd2lsbCcsICdpdCBjYW4nLCAnaXQgbWF5JyxcbiAgICAnYXMgd2VsbCcsICdhcyB3ZWxsIGFzJywgJ3N1Y2ggYXMnLCAnZm9yIGV4YW1wbGUnLCAnZm9yIGluc3RhbmNlJywgJ2luIGFkZGl0aW9uJywgJ2luIGZhY3QnLCAnaW4gb3JkZXInLFxuICAgICdhdCBsZWFzdCcsICdhdCBtb3N0JywgJ2F0IGFsbCcsICdhdCBvbmNlJywgJ2F0IGZpcnN0JywgJ2F0IGxhc3QnLCAnYXQgYmVzdCcsICdhdCB3b3JzdCcsXG4gICAgJ29uIHRoZSBvdGhlciBoYW5kJywgJ29uIHRoZSBjb250cmFyeScsICdvbiBhdmVyYWdlJywgJ29uIHB1cnBvc2UnLCAnb24gdGltZScsICdvbiBzY2hlZHVsZScsXG4gICAgJ2luIGdlbmVyYWwnLCAnaW4gcGFydGljdWxhcicsICdpbiBkZXRhaWwnLCAnaW4gc3VtbWFyeScsICdpbiBjb25jbHVzaW9uJywgJ2luIG90aGVyIHdvcmRzJyxcbiAgICAnZm9yIHRoZSBtb3N0IHBhcnQnLCAnZm9yIHRoZSB0aW1lIGJlaW5nJywgJ2ZvciB0aGUgc2FrZSBvZicsICdmb3IgdGhlIHB1cnBvc2Ugb2YnLFxuICAgICdhcyBhIHJlc3VsdCcsICdhcyBhIG1hdHRlciBvZiBmYWN0JywgJ2FzIGEgd2hvbGUnLCAnYXMgYSBydWxlJywgJ2FzIGEgY29uc2VxdWVuY2UnLFxuICAgICdkdWUgdG8nLCAnYmVjYXVzZSBvZicsICdpbiBzcGl0ZSBvZicsICdpbnN0ZWFkIG9mJywgJ3JhdGhlciB0aGFuJywgJ21vcmUgdGhhbicsICdsZXNzIHRoYW4nLFxuICAgICd1cCB0bycsICdkb3duIHRvJywgJ292ZXIgdG8nLCAndW5kZXIgdG8nLCAndGhyb3VnaCB0bycsICdhY3Jvc3MgdG8nLCAnYXJvdW5kIHRvJyxcbiAgICAnZGVlcCBzZWEnLCAnY2VsbCBkZWF0aCcsICdwcm90ZWluIHN5bnRoZXNpcycsICdETkEgcmVwbGljYXRpb24nLCAnZ2VuZSBleHByZXNzaW9uJ1xuICBdXG4gIFxuICByZXR1cm4gY29tbW9uUGhyYXNlcy5pbmNsdWRlcyhwaHJhc2UudG9Mb3dlckNhc2UoKSlcbn1cblxuYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVEZWZpbml0aW9uKHdvcmQ6IHN0cmluZywgdGV4dDogc3RyaW5nLCBmaW5nZXJwcmludDogYW55KTogUHJvbWlzZTx7IGRlZmluaXRpb246IHN0cmluZzsgaXNHUFQ6IGJvb2xlYW4gfT4ge1xuICAvLyBDaGVjayBpZiBPcGVuQUkgQVBJIGtleSBpcyBjb25maWd1cmVkXG4gIGlmICghcHJvY2Vzcy5lbnYuT1BFTkFJX0FQSV9LRVkgfHwgcHJvY2Vzcy5lbnYuT1BFTkFJX0FQSV9LRVkgPT09ICd5b3VyLW9wZW5haS1hcGkta2V5Jykge1xuICAgIGNvbnNvbGUubG9nKCdPcGVuQUkgQVBJIGtleSBub3QgY29uZmlndXJlZCwgdXNpbmcgZmFsbGJhY2sgc2VtYW50aWMgYW5hbHlzaXMgZm9yOicsIHdvcmQpXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7IGRlZmluaXRpb246IGdlbmVyYXRlU2VtYW50aWNEZWZpbml0aW9uKHdvcmQsIHRleHQsIGZpbmdlcnByaW50KSwgaXNHUFQ6IGZhbHNlIH0pXG4gIH1cblxuICB0cnkge1xuICAgIC8vIFVzZSBHUFQgdG8gZ2VuZXJhdGUgaW50ZWxsaWdlbnQga2V5d29yZCBkZWZpbml0aW9uXG4gICAgY29uc3QgY29udGV4dCA9IGV4dHJhY3RDb250ZXh0KHRleHQsIHdvcmQsIDIwMClcbiAgICBjb25zdCBkb21haW5zID0gZmluZ2VycHJpbnQuZG9tYWluSW5kaWNhdG9ycy5qb2luKCcsICcpIHx8ICdnZW5lcmFsJ1xuICAgIFxuICAgIGNvbnN0IHByb21wdCA9IGBcbkFuYWx5emUgdGhlIGZvbGxvd2luZyBrZXl3b3JkIGFuZCBwcm92aWRlIGEgY2xlYXIsIGNvbmNpc2UgZGVmaW5pdGlvbiBiYXNlZCBvbiBpdHMgdXNhZ2UgaW4gdGhlIGRvY3VtZW50IGNvbnRleHQuIEZvY3VzIG9uOlxuXG4xLiBXaGF0IHRoZSB0ZXJtIG1lYW5zIGluIHRoaXMgc3BlY2lmaWMgY29udGV4dFxuMi4gSXRzIHJvbGUgb3IgZnVuY3Rpb24gaW4gdGhlIGRvY3VtZW50XG4zLiBBbnkgdGVjaG5pY2FsIG9yIGRvbWFpbi1zcGVjaWZpYyBtZWFuaW5nXG40LiBLZWVwIHRoZSBkZWZpbml0aW9uIGluZm9ybWF0aXZlIGJ1dCBhY2Nlc3NpYmxlXG5cbktleXdvcmQ6IFwiJHt3b3JkfVwiXG5Eb2N1bWVudCBDb250ZXh0OiBcIiR7Y29udGV4dH1cIlxuRG9tYWluOiAke2RvbWFpbnN9XG5cblByb3ZpZGUgYSBjbGVhciwgaGVscGZ1bCBkZWZpbml0aW9uIGluIDEtMiBzZW50ZW5jZXM6YFxuXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBvcGVuYWkuY2hhdC5jb21wbGV0aW9ucy5jcmVhdGUoe1xuICAgICAgbW9kZWw6IFwiZ3B0LTRcIixcbiAgICAgIG1lc3NhZ2VzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICByb2xlOiBcInN5c3RlbVwiLFxuICAgICAgICAgIGNvbnRlbnQ6IFwiWW91IGFyZSBhIGhlbHBmdWwgYXNzaXN0YW50IHRoYXQgcHJvdmlkZXMgY2xlYXIsIGNvbmNpc2UgZGVmaW5pdGlvbnMgb2YgdGVjaG5pY2FsIHRlcm1zIGJhc2VkIG9uIHRoZWlyIHVzYWdlIGluIGRvY3VtZW50cy4gRm9jdXMgb24gbWFraW5nIGNvbXBsZXggY29uY2VwdHMgYWNjZXNzaWJsZSBhbmQgdW5kZXJzdGFuZGFibGUuXCJcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIHJvbGU6IFwidXNlclwiLFxuICAgICAgICAgIGNvbnRlbnQ6IHByb21wdFxuICAgICAgICB9XG4gICAgICBdLFxuICAgICAgbWF4X3Rva2VuczogMTUwLFxuICAgICAgdGVtcGVyYXR1cmU6IDAuNyxcbiAgICB9KVxuXG4gICAgY29uc3QgZGVmaW5pdGlvbiA9IHJlc3BvbnNlLmNob2ljZXNbMF0/Lm1lc3NhZ2U/LmNvbnRlbnQ/LnRyaW0oKVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoeyBcbiAgICAgIGRlZmluaXRpb246IGRlZmluaXRpb24gfHwgZ2VuZXJhdGVTZW1hbnRpY0RlZmluaXRpb24od29yZCwgdGV4dCwgZmluZ2VycHJpbnQpLCBcbiAgICAgIGlzR1BUOiAhIWRlZmluaXRpb24gXG4gICAgfSlcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdHUFQga2V5d29yZCBkZWZpbml0aW9uIGdlbmVyYXRpb24gZmFpbGVkIGZvcjonLCB3b3JkLCBlcnJvcilcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHsgZGVmaW5pdGlvbjogZ2VuZXJhdGVTZW1hbnRpY0RlZmluaXRpb24od29yZCwgdGV4dCwgZmluZ2VycHJpbnQpLCBpc0dQVDogZmFsc2UgfSlcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZVNlbWFudGljRGVmaW5pdGlvbih3b3JkOiBzdHJpbmcsIHRleHQ6IHN0cmluZywgZmluZ2VycHJpbnQ6IGFueSk6IHN0cmluZyB7XG4gIC8vIEdlbmVyYXRlIGNvbnRleHR1YWwgZGVmaW5pdGlvbiBiYXNlZCBvbiB1c2FnZSBwYXR0ZXJuc1xuICBjb25zdCBjb250ZXh0ID0gZXh0cmFjdENvbnRleHQodGV4dCwgd29yZCwgMjAwKVxuICBcbiAgLy8gTG9vayBmb3IgZGVmaW5pdGlvbiBwYXR0ZXJuc1xuICBjb25zdCBkZWZpbml0aW9uUGF0dGVybnMgPSBbXG4gICAgbmV3IFJlZ0V4cChgJHt3b3JkfVxcXFxzKig/OmlzfGFyZXxyZWZlcnMgdG98bWVhbnN8ZGVub3Rlc3xyZXByZXNlbnRzKVxcXFxzKihbXi5dezEwLDEwMH0pYCwgJ2knKSxcbiAgICBuZXcgUmVnRXhwKGAoPzppc3xhcmV8cmVmZXJzIHRvfG1lYW5zfGRlbm90ZXN8cmVwcmVzZW50cylcXFxccyoke3dvcmR9XFxcXHMqKFteLl17MTAsMTAwfSlgLCAnaScpLFxuICAgIG5ldyBSZWdFeHAoYCR7d29yZH1cXFxccypcXFxcKChbXildezEwLDEwMH0pXFxcXClgLCAnaScpXG4gIF1cbiAgXG4gIGZvciAoY29uc3QgcGF0dGVybiBvZiBkZWZpbml0aW9uUGF0dGVybnMpIHtcbiAgICBjb25zdCBtYXRjaCA9IGNvbnRleHQubWF0Y2gocGF0dGVybilcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIHJldHVybiBtYXRjaFsxXS50cmltKClcbiAgICB9XG4gIH1cbiAgXG4gIC8vIEZhbGxiYWNrOiBnZW5lcmF0ZSBkZWZpbml0aW9uIGJhc2VkIG9uIGRvbWFpbiBhbmQgY29udGV4dFxuICBjb25zdCBkb21haW5zID0gZmluZ2VycHJpbnQuZG9tYWluSW5kaWNhdG9yc1xuICBpZiAoZG9tYWlucy5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIGBBICR7ZG9tYWluc1swXS50b0xvd2VyQ2FzZSgpfSB0ZXJtIHJlZmVycmluZyB0byAke3dvcmQudG9Mb3dlckNhc2UoKX1gXG4gIH1cbiAgXG4gIHJldHVybiBgQSB0ZWNobmljYWwgdGVybSB1c2VkIGluIHRoaXMgY29udGV4dGBcbn1cblxuZnVuY3Rpb24gaXNDb21tb25Xb3JkKHdvcmQ6IHN0cmluZyk6IGJvb2xlYW4ge1xuICBjb25zdCBjb21tb25Xb3JkcyA9IG5ldyBTZXQoW1xuICAgICd0aGUnLCAnYW5kJywgJ2ZvcicsICdhcmUnLCAnYnV0JywgJ25vdCcsICd5b3UnLCAnYWxsJywgJ2NhbicsICdoYWQnLCAnaGVyJywgJ3dhcycsICdvbmUnLCAnb3VyJywgJ291dCcsXG4gICAgJ2RheScsICdnZXQnLCAnaGFzJywgJ2hpbScsICdoaXMnLCAnaG93JywgJ2l0cycsICdtYXknLCAnbmV3JywgJ25vdycsICdvbGQnLCAnc2VlJywgJ3R3bycsICd3aG8nLCAnYm95JyxcbiAgICAnZGlkJywgJ21hbicsICdtZW4nLCAncHV0JywgJ3NheScsICdzaGUnLCAndG9vJywgJ3VzZScsICd3YXknLCAnd2lsbCcsICd3aXRoJywgJ3RoaXMnLCAndGhhdCcsICd0aGV5JyxcbiAgICAnaGF2ZScsICdiZWVuJywgJ3dlcmUnLCAnc2FpZCcsICdlYWNoJywgJ3doaWNoJywgJ3RoZWlyJywgJ3RpbWUnLCAnYWJvdXQnLCAndGhlcmUnLCAnY291bGQnLCAnb3RoZXInLFxuICAgICdhZnRlcicsICdmaXJzdCcsICd3ZWxsJywgJ2Fsc28nLCAnd2hlcmUnLCAnbXVjaCcsICdzb21lJywgJ3RoZXNlJywgJ3RoYW4nLCAnd291bGQnLCAnbGlrZScsICdpbnRvJyxcbiAgICAnbW9yZScsICdjb21lJywgJ21hZGUnLCAnbWFueScsICdtb3N0JywgJ292ZXInLCAnc3VjaCcsICd0YWtlJywgJ3RoYW4nLCAndGhlbScsICd2ZXJ5JywgJ3doZW4nLCAnd29yaycsXG4gICAgJ3llYXInLCAneW91cicsICdnb29kJywgJ2tub3cnLCAnanVzdCcsICdsb25nJywgJ21ha2UnLCAncmlnaHQnLCAnc2FtZScsICdzZWVtJywgJ3RlbGwnLCAndHVybicsICd3YW50JyxcbiAgICAnd2VudCcsICd3ZXJlJywgJ3doYXQnLCAnd2hlbicsICd3aWxsJywgJ3dpdGgnLCAnd29yaycsICd5ZWFyJywgJ3lvdXInLCAnaGVyZScsICd0aGVyZScsICd3aGVyZScsICd3aHknLFxuICAgICdob3cnLCAnd2hhdCcsICd3aGVuJywgJ3doZXJlJywgJ3doeScsICdob3cnLCAnd2hhdCcsICd3aGVuJywgJ3doZXJlJywgJ3doeScsICdob3cnLCAnd2hhdCcsICd3aGVuJ1xuICBdKVxuICBcbiAgcmV0dXJuIGNvbW1vbldvcmRzLmhhcyh3b3JkLnRvTG93ZXJDYXNlKCkpXG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RDb250ZXh0KHRleHQ6IHN0cmluZywgdGVybTogc3RyaW5nLCBjb250ZXh0TGVuZ3RoOiBudW1iZXIgPSAxMDApOiBzdHJpbmcge1xuICBjb25zdCBpbmRleCA9IHRleHQudG9Mb3dlckNhc2UoKS5pbmRleE9mKHRlcm0udG9Mb3dlckNhc2UoKSlcbiAgaWYgKGluZGV4ID09PSAtMSkgcmV0dXJuICcnXG4gIFxuICBjb25zdCBzdGFydCA9IE1hdGgubWF4KDAsIGluZGV4IC0gY29udGV4dExlbmd0aClcbiAgY29uc3QgZW5kID0gTWF0aC5taW4odGV4dC5sZW5ndGgsIGluZGV4ICsgdGVybS5sZW5ndGggKyBjb250ZXh0TGVuZ3RoKVxuICBcbiAgcmV0dXJuIHRleHQuc3Vic3RyaW5nKHN0YXJ0LCBlbmQpLnRyaW0oKVxufVxuXG5mdW5jdGlvbiBjbGVhblRleHRGb3JLZXl3b3JkRGV0ZWN0aW9uKHRleHQ6IHN0cmluZyk6IHN0cmluZyB7XG4gIGxldCBjbGVhbmVkVGV4dCA9IHRleHRcbiAgXG4gIC8vIFJlbW92ZSByZWZlcmVuY2VzL2JpYmxpb2dyYXBoeSBzZWN0aW9uc1xuICBjbGVhbmVkVGV4dCA9IGNsZWFuZWRUZXh0LnJlcGxhY2UoLyhyZWZlcmVuY2VzP3xiaWJsaW9ncmFwaHl8d29ya3MgY2l0ZWR8c291cmNlcz8pXFxzKjo/LiokL2dpbSwgJycpXG4gIFxuICAvLyBSZW1vdmUgQ3JlYXRpdmUgQ29tbW9ucyBhbmQgY29weXJpZ2h0IGluZm9ybWF0aW9uXG4gIGNsZWFuZWRUZXh0ID0gY2xlYW5lZFRleHQucmVwbGFjZSgvY3JlYXRpdmUgY29tbW9ucy4qPyQvZ2ltLCAnJylcbiAgY2xlYW5lZFRleHQgPSBjbGVhbmVkVGV4dC5yZXBsYWNlKC9jb3B5cmlnaHQuKj8kL2dpbSwgJycpXG4gIGNsZWFuZWRUZXh0ID0gY2xlYW5lZFRleHQucmVwbGFjZSgvwqkuKj8kL2dpbSwgJycpXG4gIGNsZWFuZWRUZXh0ID0gY2xlYW5lZFRleHQucmVwbGFjZSgvYWxsIHJpZ2h0cyByZXNlcnZlZC4qPyQvZ2ltLCAnJylcbiAgXG4gIC8vIFJlbW92ZSBhdXRob3IgYWZmaWxpYXRpb25zIGFuZCBhY2tub3dsZWRnbWVudHNcbiAgY2xlYW5lZFRleHQgPSBjbGVhbmVkVGV4dC5yZXBsYWNlKC9hY2tub3dsZWRnbWVudHM/Lio/JC9naW0sICcnKVxuICBjbGVhbmVkVGV4dCA9IGNsZWFuZWRUZXh0LnJlcGxhY2UoL2Z1bmRpbmcuKj8kL2dpbSwgJycpXG4gIGNsZWFuZWRUZXh0ID0gY2xlYW5lZFRleHQucmVwbGFjZSgvYXV0aG9yIGFmZmlsaWF0aW9ucz8uKj8kL2dpbSwgJycpXG4gIFxuICAvLyBSZW1vdmUgYWJzdHJhY3QgYW5kIG1ldGFkYXRhIHNlY3Rpb25zXG4gIGNsZWFuZWRUZXh0ID0gY2xlYW5lZFRleHQucmVwbGFjZSgvYWJzdHJhY3RcXHMqOj8uKj8oPz1cXG5cXG58XFxuW0EtWl18JCkvZ2ltLCAnJylcbiAgY2xlYW5lZFRleHQgPSBjbGVhbmVkVGV4dC5yZXBsYWNlKC9rZXl3b3Jkcz9cXHMqOj8uKj8oPz1cXG5cXG58XFxuW0EtWl18JCkvZ2ltLCAnJylcbiAgXG4gIC8vIFJlbW92ZSBwYWdlIG51bWJlcnMgYW5kIGhlYWRlcnMvZm9vdGVyc1xuICBjbGVhbmVkVGV4dCA9IGNsZWFuZWRUZXh0LnJlcGxhY2UoL15cXHMqXFxkK1xccyokL2dtLCAnJykgLy8gU3RhbmRhbG9uZSBwYWdlIG51bWJlcnNcbiAgY2xlYW5lZFRleHQgPSBjbGVhbmVkVGV4dC5yZXBsYWNlKC9ecGFnZSBcXGQrLiokL2dpbSwgJycpIC8vIFwiUGFnZSBYXCIgaGVhZGVyc1xuICBcbiAgLy8gUmVtb3ZlIGxlZ2FsIGRpc2NsYWltZXJzIGFuZCBib2lsZXJwbGF0ZVxuICBjbGVhbmVkVGV4dCA9IGNsZWFuZWRUZXh0LnJlcGxhY2UoL2Rpc2NsYWltZXIuKj8kL2dpbSwgJycpXG4gIGNsZWFuZWRUZXh0ID0gY2xlYW5lZFRleHQucmVwbGFjZSgvdGVybXMgb2YgdXNlLio/JC9naW0sICcnKVxuICBjbGVhbmVkVGV4dCA9IGNsZWFuZWRUZXh0LnJlcGxhY2UoL3ByaXZhY3kgcG9saWN5Lio/JC9naW0sICcnKVxuICBcbiAgLy8gUmVtb3ZlIGV4Y2Vzc2l2ZSB3aGl0ZXNwYWNlIGFuZCBub3JtYWxpemVcbiAgY2xlYW5lZFRleHQgPSBjbGVhbmVkVGV4dC5yZXBsYWNlKC9cXG5cXHMqXFxuXFxzKlxcbi9nLCAnXFxuXFxuJykgLy8gTXVsdGlwbGUgbmV3bGluZXMgdG8gZG91YmxlXG4gIGNsZWFuZWRUZXh0ID0gY2xlYW5lZFRleHQucmVwbGFjZSgvXlxccyt8XFxzKyQvZ20sICcnKSAvLyBUcmltIGVhY2ggbGluZVxuICBjbGVhbmVkVGV4dCA9IGNsZWFuZWRUZXh0LnRyaW0oKVxuICBcbiAgcmV0dXJuIGNsZWFuZWRUZXh0XG59XG4iXSwibmFtZXMiOlsiTmV4dFJlc3BvbnNlIiwiT3BlbkFJIiwib3BlbmFpIiwiYXBpS2V5IiwicHJvY2VzcyIsImVudiIsIk9QRU5BSV9BUElfS0VZIiwiUE9TVCIsInJlcXVlc3QiLCJ0ZXh0IiwianNvbiIsImVycm9yIiwic3RhdHVzIiwia2V5d29yZHMiLCJzZW1hbnRpY0ZpbmdlcnByaW50S2V5d29yZERldGVjdGlvbiIsImNvbnNvbGUiLCJmb3VuZFRlcm1zIiwiU2V0IiwiY2xlYW5UZXh0IiwiY2xlYW5UZXh0Rm9yS2V5d29yZERldGVjdGlvbiIsInNlbWFudGljRmluZ2VycHJpbnQiLCJhbmFseXplU2VtYW50aWNGaW5nZXJwcmludCIsInN0cmF0ZWdpZXMiLCJleHRyYWN0VGVjaG5pY2FsVGVybXMiLCJleHRyYWN0RnJlcXVlbnRJbnRlZ3JhbFRlcm1zIiwiZXh0cmFjdENvbnRleHR1YWxLZXl3b3JkcyIsImV4dHJhY3REb21haW5TcGVjaWZpY1Rlcm1zIiwiZXh0cmFjdFNlbWFudGljQ2x1c3RlcnMiLCJleHRyYWN0TXVsdGlXb3JkUGhyYXNlcyIsImZvckVhY2giLCJzdHJhdGVneSIsImV4dHJhY3RlZEtleXdvcmRzIiwia2V5d29yZCIsImhhcyIsIndvcmQiLCJ0b0xvd2VyQ2FzZSIsImFkZCIsInB1c2giLCJ1bmlxdWVLZXl3b3JkcyIsImZpbHRlciIsImluZGV4Iiwic2VsZiIsImZpbmRJbmRleCIsImsiLCJzb3J0IiwiYSIsImIiLCJzY29yZSIsImtleXdvcmRzV2l0aERlZmluaXRpb25zIiwiUHJvbWlzZSIsImFsbCIsInNsaWNlIiwibWFwIiwiZGVmaW5pdGlvblJlc3VsdCIsImdlbmVyYXRlRGVmaW5pdGlvbiIsImRlZmluaXRpb24iLCJjb250ZXh0IiwiaXNHUFQiLCJmaW5nZXJwcmludCIsInNlY3Rpb25zIiwiZXh0cmFjdERvY3VtZW50U2VjdGlvbnMiLCJ3b3JkRnJlcXVlbmNpZXMiLCJjYWxjdWxhdGVXb3JkRnJlcXVlbmNpZXMiLCJ0ZWNobmljYWxEZW5zaXR5IiwiY2FsY3VsYXRlVGVjaG5pY2FsRGVuc2l0eSIsInNlbWFudGljQ2x1c3RlcnMiLCJpZGVudGlmeVNlbWFudGljQ2x1c3RlcnMiLCJjb250ZXh0dWFsSW1wb3J0YW5jZSIsImNhbGN1bGF0ZUNvbnRleHR1YWxJbXBvcnRhbmNlIiwiZG9tYWluSW5kaWNhdG9ycyIsImlkZW50aWZ5RG9tYWluSW5kaWNhdG9ycyIsImFic3RyYWN0IiwiZXh0cmFjdFNlY3Rpb24iLCJpbnRyb2R1Y3Rpb24iLCJtZXRob2RvbG9neSIsInJlc3VsdHMiLCJkaXNjdXNzaW9uIiwiY29uY2x1c2lvbiIsInBhdHRlcm4iLCJtYXRjaCIsIlJlZ0V4cCIsInNvdXJjZSIsInRyaW0iLCJ3b3JkcyIsImZyZXF1ZW5jaWVzIiwidGVjaG5pY2FsUGF0dGVybnMiLCJ0ZWNobmljYWxDb3VudCIsIm1hdGNoZXMiLCJsZW5ndGgiLCJ0b3RhbFdvcmRzIiwiY2x1c3RlcnMiLCJjbHVzdGVyUGF0dGVybnMiLCJjbHVzdGVyIiwidGVybSIsInRlc3QiLCJpbXBvcnRhbmNlIiwiYWxsU2VjdGlvblRleHQiLCJPYmplY3QiLCJ2YWx1ZXMiLCJqb2luIiwid29yZENvdW50cyIsImVudHJpZXMiLCJjb3VudCIsInNlY3Rpb24iLCJpbmNsdWRlcyIsImRvbWFpblBhdHRlcm5zIiwiZG9tYWlucyIsImRvbWFpbk5hbWVzIiwid2VpZ2h0IiwiaXNDb21tb25Xb3JkIiwiZXh0cmFjdENvbnRleHQiLCJmcmVxdWVuY3kiLCJjb250ZXh0dWFsU2NvcmUiLCJjaGFyQXQiLCJ0b1VwcGVyQ2FzZSIsInNlY3Rpb25UZXJtcyIsInNlY3Rpb25OYW1lIiwic2VjdGlvblRleHQiLCJzZWN0aW9uQ291bnQiLCJkb21haW5UZXJtcyIsInJlZ2V4IiwicGhyYXNlUGF0dGVybnMiLCJwaHJhc2UiLCJpc0NvbW1vblBocmFzZSIsInBocmFzZUNvdW50cyIsImkiLCJzcGxpdCIsImNvbW1vblBocmFzZXMiLCJsb2ciLCJyZXNvbHZlIiwiZ2VuZXJhdGVTZW1hbnRpY0RlZmluaXRpb24iLCJwcm9tcHQiLCJyZXNwb25zZSIsImNoYXQiLCJjb21wbGV0aW9ucyIsImNyZWF0ZSIsIm1vZGVsIiwibWVzc2FnZXMiLCJyb2xlIiwiY29udGVudCIsIm1heF90b2tlbnMiLCJ0ZW1wZXJhdHVyZSIsImNob2ljZXMiLCJtZXNzYWdlIiwiZGVmaW5pdGlvblBhdHRlcm5zIiwiY29tbW9uV29yZHMiLCJjb250ZXh0TGVuZ3RoIiwiaW5kZXhPZiIsInN0YXJ0IiwiTWF0aCIsIm1heCIsImVuZCIsIm1pbiIsInN1YnN0cmluZyIsImNsZWFuZWRUZXh0IiwicmVwbGFjZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./app/api/detect-keywords/route.ts\n");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../../webpack-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/next","vendor-chunks/formdata-node","vendor-chunks/ms","vendor-chunks/openai","vendor-chunks/tr46","vendor-chunks/web-streams-polyfill","vendor-chunks/node-fetch","vendor-chunks/whatwg-url","vendor-chunks/event-target-shim","vendor-chunks/agentkeepalive","vendor-chunks/form-data-encoder","vendor-chunks/webidl-conversions","vendor-chunks/abort-controller","vendor-chunks/humanize-ms"], () => (__webpack_exec__("(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fdetect-keywords%2Froute&page=%2Fapi%2Fdetect-keywords%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fdetect-keywords%2Froute.ts&appDir=%2Fhome%2Frishi%2FDesktop%2Fhackathon%2FHelloWorld2025%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2Fhome%2Frishi%2FDesktop%2Fhackathon%2FHelloWorld2025&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!")));
module.exports = __webpack_exports__;

})();